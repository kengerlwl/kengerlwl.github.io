<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>计算机网络 - Kenger`s Blog</title><meta name="Description" content="Hugo theme - LoveIt"><meta property="og:url" content="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
  <meta property="og:site_name" content="Kenger`s Blog">
  <meta property="og:title" content="计算机网络">
  <meta property="og:description" content="概述 ISP 互联网服务提供商 ISP 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-22T15:27:31+00:00">
    <meta property="article:modified_time" content="2023-08-22T15:27:31+00:00">
    <meta property="article:tag" content="计算机网络">
    <meta property="og:image" content="https://kengerlwl.github.io/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://kengerlwl.github.io/logo.png">
  <meta name="twitter:title" content="计算机网络">
  <meta name="twitter:description" content="概述 ISP 互联网服务提供商 ISP 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务">
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" /><link rel="prev" href="https://kengerlwl.github.io/%E7%AE%80%E5%8E%86%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" /><link rel="next" href="https://kengerlwl.github.io/%E5%85%B6%E4%BB%96/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "计算机网络",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/kengerlwl.github.io\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/kengerlwl.github.io\/images\/4.jpg",
                            "width":  1280 ,
                            "height":  720 
                        }],"genre": "posts","keywords": "计算机网络","wordcount":  18356 ,
        "url": "https:\/\/kengerlwl.github.io\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\/","datePublished": "2023-08-22T15:27:31+00:00","dateModified": "2023-08-22T15:27:31+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "kenger","logo": {
                    "@type": "ImageObject",
                    "url": "https:\/\/kengerlwl.github.io\/images\/avatar.png",
                    "width":  1080 ,
                    "height":  1080 
                }},"author": {
                "@type": "Person",
                "name": "kenger"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Kenger`s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="https://kengerlwl.github.io/favicon-16x16.ico"
        data-srcset="https://kengerlwl.github.io/favicon-16x16.ico, https://kengerlwl.github.io/favicon-16x16.ico 1.5x, https://kengerlwl.github.io/favicon-16x16.ico 2x"
        data-sizes="auto"
        alt="https://kengerlwl.github.io/favicon-16x16.ico"
        title="https://kengerlwl.github.io/favicon-16x16.ico" /><span class="header-title-pre"> <i class='far' aria-hidden='true'></i></span>Kenger`s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/kengerlwl/kengerlwl.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" selected>简体中文</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Kenger`s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="https://kengerlwl.github.io/favicon-16x16.ico"
        data-srcset="https://kengerlwl.github.io/favicon-16x16.ico, https://kengerlwl.github.io/favicon-16x16.ico 1.5x, https://kengerlwl.github.io/favicon-16x16.ico 2x"
        data-sizes="auto"
        alt="https://kengerlwl.github.io/favicon-16x16.ico"
        title="https://kengerlwl.github.io/favicon-16x16.ico" /><span class="header-title-pre"> <i class='far' aria-hidden='true'></i></span>Kenger`s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/kengerlwl/kengerlwl.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw' aria-hidden='true'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" selected>简体中文</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">计算机网络</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://kengerlwl.github.io/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>kenger</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/find-job/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Find JOB</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-08-22">2023-08-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 18356 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 37 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#isp">ISP</a></li>
    <li><a href="#主机之间的通信方式">主机之间的通信方式</a></li>
    <li><a href="#互联网上的数据传输模式">互联网上的数据传输模式：</a></li>
    <li><a href="#计算机网络体系结构">计算机网络体系结构</a>
      <ul>
        <li><a href="#五层协议">五层协议</a></li>
        <li><a href="#osi">OSI</a></li>
        <li><a href="#tcpip">TCP/IP</a></li>
        <li><a href="#数据在各层之间的传递过程">数据在各层之间的传递过程</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#通信方式">通信方式</a></li>
  </ul>

  <ul>
    <li><a href="#基本功能">基本功能</a></li>
    <li><a href="#信道分类">信道分类</a></li>
    <li><a href="#信道复用技术">信道复用技术</a></li>
    <li><a href="#csmacd-协议">CSMA/CD 协议</a></li>
    <li><a href="#ppp-协议">PPP 协议</a></li>
    <li><a href="#mac-地址">MAC 地址</a></li>
    <li><a href="#交换机">交换机</a></li>
    <li><a href="#虚拟局域网vlan处于链路层">虚拟局域网VLAN（处于链路层）</a></li>
  </ul>

  <ul>
    <li><a href="#ip-地址编址方式">IP 地址编址方式</a></li>
    <li><a href="#地址解析协议-arp">地址解析协议 ARP</a></li>
    <li><a href="#网际控制报文协议-icmp挺重要">网际控制报文协议 ICMP（挺重要）</a>
      <ul>
        <li><a href="#ping">Ping</a></li>
        <li><a href="#traceroute">Traceroute</a></li>
      </ul>
    </li>
    <li><a href="#虚拟专用网-vpn">虚拟专用网 VPN</a></li>
    <li><a href="#网络地址转换-nat">网络地址转换 NAT</a></li>
    <li><a href="#路由器分组转发流程这个我比较熟">路由器分组转发流程（这个我比较熟）</a></li>
  </ul>

  <ul>
    <li><a href="#udp-和-tcp-的特点">UDP 和 TCP 的特点</a></li>
    <li><a href="#tcp-首部格式flags标志">TCP 首部格式（flags标志）</a></li>
    <li><a href="#tcp-的三次握手">TCP 的三次握手</a>
      <ul>
        <li><a href="#第一次握手丢失">第一次握手丢失</a></li>
        <li><a href="#第二次握手丢失">第二次握手丢失</a></li>
        <li><a href="#第三次握手丢失">第三次握手丢失</a></li>
      </ul>
    </li>
    <li><a href="#tcp两次握手和四次握手的不必要">TCP两次握手和四次握手的不必要</a>
      <ul>
        <li><a href="#tcp-三次握手能否携带数据">TCP 三次握手能否携带数据？</a></li>
      </ul>
    </li>
    <li><a href="#tcp-的四次挥手">TCP 的四次挥手</a></li>
    <li><a href="#tcp沾包和拆包">TCP沾包和拆包</a></li>
    <li><a href="#tcp的流量控制">TCP的流量控制</a></li>
    <li><a href="#tcp-可靠传输">TCP 可靠传输</a></li>
    <li><a href="#tcp-滑动窗口">TCP 滑动窗口</a></li>
    <li><a href="#tcp-流量控制">TCP 流量控制</a></li>
    <li><a href="#tcp-拥塞控制先慢拥塞避免指数到线性再快重传并恢复">TCP 拥塞控制（先慢+拥塞避免（指数到线性），再快重传并恢复。）</a></li>
  </ul>

  <ul>
    <li><a href="#dns">DNS</a></li>
    <li><a href="#文件传送协议">文件传送协议</a></li>
    <li><a href="#动态主机配置协议">动态主机配置协议</a></li>
    <li><a href="#远程登录协议">远程登录协议</a></li>
    <li><a href="#电子邮件协议">电子邮件协议</a></li>
    <li><a href="#socket接口并不是协议">socket接口（并不是协议）</a></li>
  </ul>

  <ul>
    <li><a href="#从浏览器地址栏输入url到显示主页的过程">从浏览器地址栏输入url到显示主页的过程？</a></li>
    <li><a href="#http101120">HTTP1.0,1.1,2.0</a></li>
    <li><a href="#https的加密流程是怎样的">HTTPS的加密流程是怎样的？</a></li>
    <li><a href="#tcp-和-udp-分别对应的常见应用层协议有哪些">TCP 和 UDP 分别对应的常见应用层协议有哪些？</a></li>
    <li><a href="#http缓存有哪些">HTTP缓存有哪些？</a></li>
    <li><a href="#如何在-linux-系统中查看-tcp-状态">如何在 Linux 系统中查看 TCP 状态？</a></li>
    <li><a href="#说说http常用的状态码及其含义">说说HTTP常用的状态码及其含义？</a></li>
    <li><a href="#http和rpc">HTTP和RPC</a></li>
    <li><a href="#http缓存有哪些强制缓存和协商缓存">HTTP缓存有哪些？（强制缓存和协商缓存）</a></li>
    <li><a href="#各种网络攻击原理">各种网络攻击原理</a>
      <ul>
        <li><a href="#什么是-syn-攻击如何避免-syn-攻击">什么是 SYN 攻击？如何避免 SYN 攻击？</a></li>
        <li><a href="#udp-flood-攻击原理是什么">UDP Flood 攻击原理是什么？</a></li>
        <li><a href="#http-flood-攻击原理是什么">HTTP Flood 攻击原理是什么？</a></li>
        <li><a href="#tcp重置攻击rst报文">TCP重置攻击（RST报文）</a></li>
        <li><a href="#ddos攻击">ddos攻击</a></li>
      </ul>
    </li>
    <li><a href="#websocket连接">websocket连接</a></li>
    <li><a href="#kcp和quic">KCP和QUIC</a>
      <ul>
        <li><a href="#kcp">KCP</a></li>
        <li><a href="#quic">QUIC</a></li>
      </ul>
    </li>
    <li><a href="#wafweb-application-firewall">WAF（Web Application Firewall）</a></li>
    <li><a href="#听说过graphql吗">听说过graphQL吗？</a></li>
    <li><a href="#bbr协议">BBR协议</a></li>
    <li><a href="#http的keep-alive和tcp的keepalive">http的keep-alive和tcp的KeepAlive</a></li>
    <li><a href="#已建立连接的tcp收到syn会发生什么">已建立连接的TCP，收到SYN会发生什么？</a></li>
    <li><a href="#在-time_wait-状态的-tcp-连接收到-syn-后会发生什么">在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</a></li>
    <li><a href="#tcp-存在队头阻塞问题">TCP 存在队头阻塞问题</a></li>
    <li><a href="#如何基于-udp-协议实现可靠传输">如何基于 UDP 协议实现可靠传输？</a>
      <ul>
        <li><a href="#packet-header">Packet Header</a></li>
        <li><a href="#quic-frame-header">QUIC Frame Header</a></li>
      </ul>
    </li>
    <li><a href="#tcp-和-udp-可以同时绑定相同的端口吗">TCP 和 UDP 可以同时绑定相同的端口吗？</a></li>
    <li><a href="#一个数据包在网络中的发送过程">一个数据包在网络中的发送过程</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#1-同时打开">1. 同时打开</a></li>
        <li><a href="#2-同时关闭">2. 同时关闭</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="概述">概述</h1>
<h2 id="isp">ISP</h2>
<p>互联网服务提供商 ISP</p>
<h2 id="主机之间的通信方式">主机之间的通信方式</h2>
<ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png"
        title="img" /></p>
<ul>
<li>对等（P2P）：不区分客户和服务器。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png"
        title="img" /></p>
<h2 id="互联网上的数据传输模式">互联网上的数据传输模式：</h2>
<p><strong>分组交换</strong>：每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，<strong>因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</strong></p>
<h2 id="计算机网络体系结构">计算机网络体系结构</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png"
        title="img" /></p>
<h3 id="五层协议">五层协议</h3>
<ul>
<li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。<strong>数据单位为报文</strong>。</li>
<li><strong>传输层（进程）</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；<strong>用户数据报协议 UDP</strong>，提供无连接、尽最大努力的数据传输服务，<strong>数据单位为用户数据报</strong>。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层（主机ip）</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封<strong>装成分组</strong>。</li>
<li><strong>数据链路层（mac地址）</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组<strong>封装成帧</strong>。</li>
<li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<h3 id="osi">OSI</h3>
<p>五层协议的复杂版，多了表示层和会话层，</p>
<h3 id="tcpip">TCP/IP</h3>
<p>它只有四层，相当于五层协议中<strong>数据链路层和物理层（最下面两层）合并为网络接口层。</strong></p>
<p>TCP/IP 体系结构不<strong>严格遵循 OSI 分层概念</strong>，应用层可能会直接使用 IP 层或者网络接口层。</p>
<h3 id="数据在各层之间的传递过程">数据在各层之间的传递过程</h3>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。（<strong>越往下，越封装一层</strong>）</p>
<h1 id="物理层">物理层</h1>
<h2 id="通信方式">通信方式</h2>
<p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h1 id="链路层">链路层</h1>
<h2 id="基本功能">基本功能</h2>
<ul>
<li><strong>数据帧的传输：</strong> 链路层负责将网络层的数据包封装成数据帧，以便在物理介质上进行传输。</li>
<li><strong>介质访问控制：</strong> 链路层通过介质访问控制（MAC）协议来管理共享介质上的数据传输</li>
<li>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li>
</ul>
<h2 id="信道分类">信道分类</h2>
<ol>
<li><strong>广播信道：</strong> 允许一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。需要专门的控制方法进行协调，避免碰撞。常见的控制方法包括信道复用技术和CSMA/CD协议。</li>
<li><strong>点对点信道：</strong> 适用于一对一通信，不会发生碰撞，使用简单的PPP协议进行控制。</li>
</ol>
<h2 id="信道复用技术">信道复用技术</h2>
<ol>
<li>
<p><strong>频分复用（FDM）：</strong> 将通信<strong>频段划分</strong>为多个不重叠的子频段，每个用户或信道占据一个特定的频段进行通信。常见于无线电通信和有线电视系统。</p>
</li>
<li>
<p><strong>时分复用（TDM）：</strong> 将通信<strong>时间段划分</strong>为若干个固定长度的时隙，不同用户或信道在不同时隙内进行通信。常见于数字通信系统和电话网络。</p>
</li>
<li>
<p><strong>码分复用（CDM）：</strong> 将<strong>数据通过不同的编码方案进行调制</strong>，然后同时发送到通信媒介上。接收端使用相应的解码方案来提取目标数据。常见于CDMA（Code Division Multiple Access）系统。</p>
</li>
<li>
<p>统计时分复用</p>
<p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
</li>
<li>
<p>统计时分复用</p>
<p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
</li>
</ol>
<p>这些信道复用技术<strong>使得多个用户能够共享同一通信媒介，从而实现了高效的通信</strong>。</p>
<h2 id="csmacd-协议">CSMA/CD 协议</h2>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<h2 id="ppp-协议">PPP 协议</h2>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，<strong>PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</strong></p>
<h2 id="mac-地址">MAC 地址</h2>
<p>MAC 地址是<strong>链路层地址，长度为 6 字节（48 位，共2*6个字母数字表示），用于唯一标识网络适配器（网卡）</strong>。（可以有虚拟网卡）</p>
<h2 id="交换机">交换机</h2>
<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<h2 id="虚拟局域网vlan处于链路层">虚拟局域网VLAN（处于链路层）</h2>
<p>**交换机通过在数据帧中标记 VLAN ID 来实现逻辑上的隔离，**使得不同 VLAN 的设备能够彼此通信，但在逻辑上却处于不同的虚拟网络中。</p>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>当一个数据帧从一个VLAN发送到另一个VLAN时，<strong>交换机会在数据帧的头部添加一个VLAN标签</strong>，该标签包含了VLAN ID。这样，接收端的交换机就可以根据VLAN ID将数据帧转发到正确的VLAN。</p>
<h1 id="网络层">网络层</h1>
<p>网络层是整个<strong>互联网的核心</strong>，因此应当让网络层尽可能简单。<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</strong></p>
<p>这一层的链接用的<strong>IP地址</strong></p>
<h2 id="ip-地址编址方式">IP 地址编址方式</h2>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<h2 id="地址解析协议-arp">地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在<strong>通信过程中，IP 数据报的源地址和目的地址始终不变</strong>，而 <strong>MAC 地址随着链路的改变而改变</strong>。</p>
<p><strong>为了应对MAC地址变换，ARP 实现由 IP 地址得到 MAC 地址。</strong></p>
<p><strong>每个主机都有一个 ARP 高速缓存</strong>，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。<code>arp -a</code>命令可以查看该映射表（向网络发送一个ARP请求的广播包）</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。（<strong>简单来说，就是通过arp请求获取到指定ip的mac地址</strong>）</p>
<h2 id="网际控制报文协议-icmp挺重要">网际控制报文协议 ICMP（挺重要）</h2>
<p>ICMP（Internet Control Message Protocol）是一种网络协议，用于<strong>在IP网络上发送控制消息</strong>。它通常用于诊断网络故障、执行网络管理任务和提供错误报告。ICMP消息通常被内置在IP数据包中，以便在网络中传输。</p>
<h3 id="ping">Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率</p>
<p>（<strong>如果在交换机禁止ICMP嗅探会怎么样：无法使用ICMP工具（例如ping）来测试网络设备之间的连通性和延迟。</strong>）</p>
<h3 id="traceroute">Traceroute</h3>
<p><strong>(用于查看数据包跳了哪些点)</strong></p>
<p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<p>源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<h2 id="虚拟专用网-vpn">虚拟专用网 VPN</h2>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255 <strong>通常被用于大型组织或企业内部的网络</strong></li>
<li>172.16.0.0 ~ 172.31.255.255 <strong>中型到大型组织的内部网络。</strong></li>
<li>192.168.0.0 ~ 192.168.255.255 <strong>家庭网络或小型办公室的内部网络</strong></li>
</ul>
<h2 id="网络地址转换-nat">网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。（<strong>主要是ipv4没有那么多ip。</strong>）</p>
<h2 id="路由器分组转发流程这个我比较熟">路由器分组转发流程（这个我比较熟）</h2>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<h1 id="传输层">传输层</h1>
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p>
<p><strong>传输层提供了进程间的逻辑通信，</strong></p>
<h2 id="udp-和-tcp-的特点">UDP 和 TCP 的特点</h2>
<ul>
<li>
<p>用户数据报协议 UDP（User Datagram Protocol）是<strong>无连接的</strong>，尽最大可能交付，没有拥塞控制，<strong>面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信。</strong></p>
</li>
<li>
<p>传输控制协议 TCP（Transmission Control Protocol）是<strong>面向连接的</strong>，提供<strong>可靠交付</strong>，有流量控制，拥塞控制，提供全双工通信，<strong>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</strong></p>
</li>
<li>
<p><strong>UDP如何变得可靠</strong>：等待确认+超时重传+编号</p>
<ul>
<li>UDP要想可靠，就要接收方收到UDP之后回复个确认包，<strong>发送方有个机制，收不到确认包就要重新发送</strong>，<strong>每个包有递增的序号，接收方发现中间丢了包就要发重传请求</strong>，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</li>
</ul>
</li>
</ul>
<h2 id="tcp-首部格式flags标志">TCP 首部格式（flags标志）</h2>
<ul>
<li>
<p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
<li>
<p><strong>RST</strong> ，重置指令，表示出现严重错误，常用于拒绝非法报文段以及拒绝连接请求；</p>
</li>
</ul>
<h2 id="tcp-的三次握手">TCP 的三次握手</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png"
        title="img" /></p>
<p><strong>① SYN(synchronous建立联机)；</strong></p>
<p><strong>② ACK(acknowledgement 确认)</strong></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p>(简单来说，就是客户端先向服务器端发送请求，表示发起连接（SYN码为1），服务器端收到后，同意建立连接（ACK为1），然后发送响应给客户端，告知自己OK了，然后客户端接受到消息，确认服务器OK后。发送消息告诉客户端自己也OK（ACK为1），到这里，服务器和客户端都确认对方OK能收发消息，开始通信。)</p>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<ol>
<li><strong>建立可靠的连接：</strong> 三次握手确保了客户端和服务器端在同一个初始序列号下建立连接，从而避免了可能出现的混乱和数据混乱。</li>
<li><strong>防止旧连接的重新建立：</strong> 由于每次连接建立都会使用不同的初始序列号，因此可以防止旧的连接被重新建立，从而增强了连接的安全性。</li>
<li><strong>减少不必要的资源占用：</strong> 如果客户端发送的连接请求在网络中因某些原因丢失，服务器将不会收到该请求，从而避免了不必要的资源占用和连接建立失败。</li>
</ol>
<h3 id="第一次握手丢失">第一次握手丢失</h3>
<p>就会触发超时重传机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的</p>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<blockquote>
<p><strong>当第五次超时重传后</strong>，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
</blockquote>
<h3 id="第二次握手丢失">第二次握手丢失</h3>
<blockquote>
<ul>
<li><strong>客户端会重传 SYN 报文</strong>，也就是第一次握手，<strong>最大重传次数由 <code>tcp_syn_retries</code>内核参数决定</strong>；</li>
<li><strong>服务端会重传 SYN-ACK 报文</strong>，也就是第二次握手，<strong>最大重传次数</strong>由 <code>tcp_synack_retries</code> 内核参数决定</li>
</ul>
</blockquote>
<h3 id="第三次握手丢失">第三次握手丢失</h3>
<p>服务端：</p>
<blockquote>
<p>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会<strong>等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK</strong>包。如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</p>
</blockquote>
<p>客户端：（<strong>客户端假设还没接受到服务器端的重发，以为已经创建了连接</strong>）</p>
<blockquote>
<p>客户端认为这个连接已经建立，<strong>如果客户端向服务端发送数据，服务端将以RST包（Reset，复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败</strong>。</p>
</blockquote>
<h2 id="tcp两次握手和四次握手的不必要">TCP两次握手和四次握手的不必要</h2>
<p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：<strong>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号</strong>；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<p><strong>三次握手建立连接的首要目的是「同步序列号」。</strong></p>
<h3 id="tcp-三次握手能否携带数据">TCP 三次握手能否携带数据？</h3>
<p><strong>第三次是可以携带数据的。</strong></p>
<p>假如第一次握手可以携带数据的话，如果恶意攻击服务器，每次都在第一次握手中的SYN报文中放入大量数据。而且频繁重复发SYN报文，服务器会花费很多的时间和内存空间去接收这些报文。</p>
<p><strong>第三次握手，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。</strong></p>
<h2 id="tcp-的四次挥手">TCP 的四次挥手</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png"
        title="img" /></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，<strong>FIN=1</strong>。</li>
<li>B 收到之后发出确认，此时 TCP <strong>属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</strong></li>
<li><strong>当 B 不再需要连接时，发送连接释放报文，FIN=1。</strong></li>
<li>A 收到后发出确认<strong>ACK=1</strong>，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接<strong>ACK=1</strong>。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p><strong>CLOSE-WAIT</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <strong>CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL（报文最大生存时间”，他是任何报文在网络上存活的最长时间，超过这个时间报文将被丢）。这么做有两个理由：</p>
<ul>
<li><strong>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</strong>（主要是怕服务器端没有收到然后重发消息给客户端）</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h2 id="tcp沾包和拆包">TCP沾包和拆包</h2>
<p>TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被TCP拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的TCP粘包和拆包问题</p>
<p><strong>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</strong></p>
<p><strong>为什么会产生粘包和拆包呢?</strong></p>
<ul>
<li>要发送的数据<strong>小于TCP发送缓冲区的大小</strong>，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li><strong>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包</strong>；</li>
<li>要<strong>发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包</strong>；</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MS</li>
</ul>
<p><strong>为了解决TCP沾包和拆包问题，通常采用以下几种方法：</strong></p>
<ul>
<li><strong>使用消息边界</strong>：在发送数据时，在数据之间添加特定的消息分隔符或者消息长度字段，接收端根据这些分隔符或长度字段来切分接收到的数据，从而保证每个消息的完整性。</li>
<li><strong>使用固定长度消息</strong>：发送端发送的每个消息都是固定长度的，接收端按照固定长度来切分接收到的数据，从而保证每个消息的完整性。</li>
</ul>
<h2 id="tcp的流量控制">TCP的流量控制</h2>
<blockquote>
<p>TCP 提供一种机制可以<strong>让发送端根据接收端的实际接收能力控制发送的数据量</strong>，这就是<strong>流量控制</strong></p>
</blockquote>
<h2 id="tcp-可靠传输">TCP 可靠传输</h2>
<p><strong>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</strong></p>
<h2 id="tcp-滑动窗口">TCP 滑动窗口</h2>
<p><strong>窗口是缓存的一部分，用来暂时存放字节流</strong>。<strong>发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</strong></p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<h2 id="tcp-流量控制">TCP 流量控制</h2>
<p><strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p>
<p><strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小</strong>，从而影响发送方的发送速率（<strong>可以通过滑动窗口设置流量大小</strong>）。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="tcp-拥塞控制先慢拥塞避免指数到线性再快重传并恢复">TCP 拥塞控制（先慢+拥塞避免（指数到线性），再快重传并恢复。）</h2>
<p>**如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。**因此当出现拥塞时，<strong>应当控制发送方的速率</strong>。这一点和流量控制很像，但是出发点不同。<strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</strong>。</p>
<p><strong>原理：</strong></p>
<hr>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念</p>
<p><strong>拥塞窗口 cwnd</strong>是<strong>发送方维护的一个的状态变量</strong>，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中<strong>没有出现拥塞，<code>cwnd</code> 就会增大</strong>；</li>
<li>但网络中<strong>出现了拥塞，<code>cwnd</code> 就减少</strong></li>
</ul>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞</p>
<hr>
<p><strong>前置声明：</strong></p>
<p><strong>超时重传。</strong></p>
<blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞</strong></p>
</blockquote>
<p><strong>快速重传（Fast Retransmit）</strong>：当<strong>发送方连续收到三个相同的确认 ACK 时，它会认为有一个分组丢失，并立即重传这个分组，而不用等待超时</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/b5ba508e38bd6d058a9f704112bb1e32.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/b5ba508e38bd6d058a9f704112bb1e32.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/b5ba508e38bd6d058a9f704112bb1e32.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/b5ba508e38bd6d058a9f704112bb1e32.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/b5ba508e38bd6d058a9f704112bb1e32.png"
        title="TCP的拥塞控制" /></p>
<p><strong>慢开始（Slow Start）和拥塞避免（Congestion Avoidance）是 TCP 拥塞控制的两个关键机制。</strong></p>
<ol>
<li><strong>慢开始（Slow Start）</strong>：在开始发送数据时，TCP 发送方会以较小的拥塞窗口大小开始发送数据。随着时间的推移和收到确认的数据包数量的增加，<strong>发送方会逐渐增加拥塞窗口的大小，指数级增长</strong>，以便测试网络的容量。<strong>如果没有发生丢包，拥塞窗口大小会快速增长，直到达到一个阈值（慢开始阈值）</strong>。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">当 cwnd &lt; ssthresh 时，使用慢启动算法。 指数增长
</span></span><span class="line"><span class="cl">当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。线性增长
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>
<p><strong>拥塞避免（Congestion Avoidance）</strong>：<strong>一旦拥塞窗口大小达到了慢开始阈值</strong>，TCP 发送方就会<strong>进入拥塞避免阶段</strong>。在这个阶段，<strong>拥塞窗口的增长变得线性</strong>，而不是指数增长。<strong>这样做是为了避免过快地增加发送的数据量，从而导致网络拥塞。</strong></p>
</li>
<li>
<p><strong>拥塞检测（Congestion Detection）</strong>：如果发送方检测到网络拥塞的迹象，如丢失数据包或收到拥塞通知，它将执行拥塞检测。在这个阶段，发送方降低其发送速率，以减轻网络负载，从而帮助缓解拥塞。</p>
</li>
</ol>
<p>如果检测出了拥塞，也就是会发生数据包重传，重传机制主要有两种：
<strong>超时重传</strong>
<strong>快速重传</strong>
当<strong>发生了「超时重传」，则就会使用拥塞发生算法。(一般不用这个，在发着这个之前，就有快速重传算法)</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">这个时候，ssthresh 和 cwnd 的值会发生变化：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ssthresh 设为 cwnd/2，
</span></span><span class="line"><span class="cl">cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>发生快速重传的拥塞发生算法（一般是执行这个）</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">则 ssthresh 和 cwnd 变化如下：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cwnd = cwnd/2 ，也就是设置为原来的一半;窗口减半，阈值变为窗口大小，立马启动拥塞避免算法，开始线性增长。进入快恢复
</span></span><span class="line"><span class="cl">ssthresh = cwnd;
</span></span><span class="line"><span class="cl">进入快速恢复算法
</span></span><span class="line"><span class="cl">#快速恢复
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li><strong>快恢复（Fast Recovery）</strong>：在进行快重传后，<strong>TCP 发送方不会立即进入慢开始阶段，而是将拥塞窗口减半，然后进入快恢复状态</strong>。在快恢复状态下，<strong>拥塞窗口大小会增加，并且继续线性增长而不是指数增长</strong>。这样可以更快地恢复到之前的发送速率。</li>
</ol>
<h1 id="应用层">应用层</h1>
<h2 id="dns">DNS</h2>
<p>DNS 是一个<strong>分布式数据库</strong>，提供了主机名和 IP 地址之间相互转换的服务。</p>
<p>**DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，**这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
<h2 id="文件传送协议">文件传送协议</h2>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：服务器端使用21端口</p>
<h2 id="动态主机配置协议">动态主机配置协议</h2>
<p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li><strong>客户端发送 Discover 报文</strong>，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 <strong>UDP 中，该报文被广播到同一个子网的所有主机上（UDP支持点对多，TCP只能点对点）</strong>。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li><strong>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端</strong>，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<h2 id="远程登录协议">远程登录协议</h2>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<h2 id="电子邮件协议">电子邮件协议</h2>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<h2 id="socket接口并不是协议">socket接口（并不是协议）</h2>
<p>Socket 不是一个严格意义上的网络层或协议，而是一个应用程序接口（API）层。因此，Socket 位于 OSI 模型的最顶层——应用层，用于帮助应用程序与传输层（如 TCP 和 UDP）进行通信。TCP与UDP都行</p>
<h1 id="其他综合网络题目">其他综合网络题目</h1>
<h2 id="从浏览器地址栏输入url到显示主页的过程">从浏览器地址栏输入url到显示主页的过程？</h2>
<blockquote>
<ol>
<li>浏览器通过域名查找对应的ip地址
<ol>
<li>DNS</li>
</ol>
</li>
<li>浏览器与服务器通过三次握手建议TCP连接</li>
<li>浏览器向服务器发送一个HTTP请求</li>
<li>服务器处理请求（处理请求参数、cookie，生成HTML响应）</li>
<li>服务器返回一个HTML响应</li>
<li>浏览器解析渲染页面</li>
<li>TCP四次挥手，结束</li>
</ol>
</blockquote>
<h2 id="http101120">HTTP1.0,1.1,2.0</h2>
<blockquote>
<p>简化版区别：</p>
<p>HTTP/1.0：默认是短连接，<strong>可以强制开启，通过加入Connection: keep - alive</strong></p>
<ul>
<li>默认使用<strong>短连接</strong>，<strong>每次请求都需要建立一个TCP连接</strong></li>
</ul>
<p>HTTP/1.1：默认为长连接</p>
<ul>
<li>最主要的改进就是引入了持久连接。所谓的持久连接即<strong>TCP连接默认不关闭，可以被多个请求复用</strong></li>
<li>引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率</li>
<li>支持断点续传</li>
</ul>
<p>HTTP/2.0：多路复用</p>
<ul>
<li><strong>多路复用：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应</strong>，而且不用按照顺序一一对应</li>
<li><strong>做了Header压缩</strong>、服务端推送等优化</li>
</ul>
<p>HTTP/3.0：基于UDP的quic协议。</p>
</blockquote>
<h2 id="https的加密流程是怎样的">HTTPS的加密流程是怎样的？</h2>
<blockquote>
<ol>
<li>发起请求（TCP链接）： 客户端在通过TCP 和服务器建立连接之后（ 443 端口），发出一个请求证书的消息给服务器，在该请求消息里包含自己可实现的算法列表和其他需要的消息。</li>
<li>证书返回：服务器端在收到消息后回应客户端并返回证书，在<strong>证书中包含服务器信息、域名、申请证书的公司、公钥、数据加密算法等。</strong></li>
<li>证书验证： <strong>客户端在收到证书后，判断证书签发机构是否正确</strong>，并使用该签发机构的公钥确认签名是否有效， 客户端还会确保在证书中列出的域名就是它正在连接的域名。如果客户端确认证书有效，则生成对称密钥，并使用公钥将对称密钥加密。</li>
<li>密钥交换： <strong>客户端将加密后的对称密钥发送给服务器</strong>，服务器在接收到对称密钥后使用私钥解密</li>
<li>数据传输： 经过上述步骤，客户端和服务器就完成了密钥对的交换， 在之后的数据传输过程中， 客户端和服务端就可以基于对称加密（ 加密和解密使用相同密钥的加密算法）对数据加密后在网络上传输，保证了网络数据传输的安全性</li>
</ol>
<p><strong>总结：实际上是一种混合加密，通过非对称加密交换了对称加密的对称秘钥</strong>，实现了安全性和性能的综合</p>
</blockquote>
<h2 id="tcp-和-udp-分别对应的常见应用层协议有哪些">TCP 和 UDP 分别对应的常见应用层协议有哪些？</h2>
<blockquote>
<p><strong>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</strong></p>
<ul>
<li><strong>HTTP</strong>：HyperText Transfer Protocol（超文本传输协议），默认端口80</li>
<li><strong>FTP</strong>: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)</li>
<li><strong>SMTP</strong>: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25</li>
<li><strong>TELNET</strong>: Teletype over the Network (网络电传), 默认端口23</li>
<li><strong>SSH</strong>：Secure Shell（安全外壳协议），默认端口 22</li>
</ul>
<p><strong>基于UDP的应用层协议：DNS、TFTP、SNMP</strong></p>
<ul>
<li><strong>DNS</strong> : Domain Name Service (域名服务),默认端口 53</li>
<li><strong>TFTP</strong>: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69</li>
<li><strong>SNMP</strong>：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162</li>
</ul>
</blockquote>
<h2 id="http缓存有哪些">HTTP缓存有哪些？</h2>
<blockquote>
<ul>
<li>强制缓存：只要<strong>浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</strong>，决定是否使用缓存的主动性在于浏览器这边，（检测到一样的请求链接，在过期时间内，直接访问本地缓存结构，不发送http请求）</li>
<li>协商缓存：通过服务端告知客户端是否可以使用缓存的方式，<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong></li>
</ul>
</blockquote>
<h2 id="如何在-linux-系统中查看-tcp-状态">如何在 Linux 系统中查看 TCP 状态？</h2>
<blockquote>
<p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png"
        title="TCP 连接状态查看" /></p>
</blockquote>
<h2 id="说说http常用的状态码及其含义">说说HTTP常用的状态码及其含义？</h2>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>信息性状态码</td>
</tr>
<tr>
<td>2XX</td>
<td>成功类状态码</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
</tr>
<tr>
<td>5XX</td>
<td>服务端错误状态码</td>
</tr>
</tbody>
</table>
<h2 id="http和rpc">HTTP和RPC</h2>
<p><strong>HTTP</strong> 协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p>
<p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。（远程调用其他服务的函数，比较有名的<code>gRPC</code>，<code>thrift</code>。）（RPC必http早）。RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</p>
<p>由于RPC可以自己根据需求研发，可以实现根据一些内部服务需求做性能上的优化。</p>
<ul>
<li>例如减去header里面一些用不上的信息</li>
<li></li>
</ul>
<h2 id="http缓存有哪些强制缓存和协商缓存">HTTP缓存有哪些？（强制缓存和协商缓存）</h2>
<blockquote>
<ul>
<li>强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边</li>
<li>协商缓存：通过服务端告知客户端是否可以使用缓存的方式，<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong></li>
</ul>
</blockquote>
<h2 id="各种网络攻击原理">各种网络攻击原理</h2>
<h3 id="什么是-syn-攻击如何避免-syn-攻击">什么是 SYN 攻击？如何避免 SYN 攻击？</h3>
<p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务</p>
<p>说明：在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li><strong>半连接队列，也称 SYN 队列；</strong></li>
<li><strong>全连接队列，也称 accept 队列；</strong></li>
</ul>
<p>SYN 攻击方式最直接的表现就<strong>会把 TCP 半连接队列打满</strong>，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，<strong>导致客户端无法和服务端建立连接。</strong></p>
<p><strong>如何处理SYN攻击</strong></p>
<ol>
<li><strong>加强网络安全策略</strong>：配置防火墙规则，限制网络流量，过滤恶意请求。</li>
<li><strong>SYN Cookies</strong>：在操作系统层面启用SYN Cookies机制，当TCP连接队列满时，使用SYN Cookies代替正常的TCP连接，防止队列耗尽。</li>
<li><strong>网络设备升级</strong>：更新和升级网络设备的固件和软件，以修复已知的SYN攻击漏洞。</li>
<li><strong>限制并发连接数</strong>：限制单个IP地址的并发连接数，减少攻击的影响范围。</li>
<li><strong>使用反向代理</strong>：使用反向代理来处理外部的网络请求，可以有效过滤掉一部分恶意流量。</li>
</ol>
<h3 id="udp-flood-攻击原理是什么">UDP Flood 攻击原理是什么？</h3>
<p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>
<ul>
<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>
<li><strong>如果没有程序在该端口接收数据包，则服务器使用 ICMP（ping）数据包进行响应，以通知发送方目的地不可达。</strong></li>
</ul>
<p>当服务器接收到每个新的 <strong>UDP</strong> 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 <strong>UDP</strong> 报文时，每个报文将包含源设备的 <strong>IP</strong> 地址。在这种类型的 <strong>DDoS</strong> 攻击期间，攻击者通常不会使用自己的真实 <strong>IP</strong> 地址，而是会欺骗 <strong>UDP</strong> 数据包的源 <strong>IP</strong> 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。</p>
<p>同时发送大量的带有隐藏IP的UDP数据包，将服务器资源迅速耗尽。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/bd80dd5b6567f5d32e8a82bf3ec52a82.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/bd80dd5b6567f5d32e8a82bf3ec52a82.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/bd80dd5b6567f5d32e8a82bf3ec52a82.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/bd80dd5b6567f5d32e8a82bf3ec52a82.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/bd80dd5b6567f5d32e8a82bf3ec52a82.png"
        title="img" /></p>
<p><strong>如何缓解 UDP Flooding？</strong></p>
<p>大多数操作系统部分<strong>限制了 ICMP 报文的响应速率</strong>，<strong>以中断需要 ICMP 响应的 DDoS 攻击</strong>。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 <strong>UDP Flood</strong> 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。</p>
<h3 id="http-flood-攻击原理是什么">HTTP Flood 攻击原理是什么？</h3>
<p>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。</p>
<p><strong>缓解原理</strong></p>
<h3 id="tcp重置攻击rst报文">TCP重置攻击（RST报文）</h3>
<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>
<p><strong>TCP</strong> 重置攻击<strong>利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。</strong></p>
<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。</p>
<h3 id="ddos攻击">ddos攻击</h3>
<p>前面很多东西都是ddos，DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。</p>
<p><strong>解决办法</strong></p>
<ul>
<li>高防服务器</li>
<li>ip黑名单</li>
<li>ddos清洗，<strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</li>
<li>CDN加速，将资源分布到不同的地方，隐藏真实ip。</li>
</ul>
<h2 id="websocket连接">websocket连接</h2>
<p>为了兼容这些使用场景。浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li>
<li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="err">Connection: Upgrade
</span></span></span><span class="line"><span class="cl"><span class="err">Upgrade: WebSocket
</span></span></span><span class="line"><span class="cl"><span class="err">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<h2 id="kcp和quic">KCP和QUIC</h2>
<h3 id="kcp">KCP</h3>
<ul>
<li><strong>简介：</strong> <strong>KCP是一种快速可靠的UDP传输协议</strong>，由著名的开源项目kcptun提供支持，旨在解决UDP在不可靠网络上的不足之处，例如高丢包率和乱序。(<strong>常用于游戏和直播等</strong>)</li>
<li><strong>特点：</strong>
<ul>
<li>高效的流量控制：KCP使用了自定义的流量控制算法，能够更好地适应不同的网络环境，从而实现更加稳定的数据传输。</li>
<li>极低的延迟：KCP在设计上考虑了延迟敏感型应用，尽可能地减少了数据传输的延迟。</li>
<li>可定制性强：KCP的参数可以根据具体的网络环境和应用需求进行调整，具有很高的灵活性</li>
</ul>
</li>
</ul>
<h3 id="quic">QUIC</h3>
<ul>
<li><strong>简介：</strong> QUIC是由Google推出的<strong>基于UDP的传输协议，旨在提供更加快速和安全的网络连接</strong>。QUIC已经被广泛应用于Google的服务中，并逐渐得到其他厂商和开发者的关注。</li>
<li><strong>特点：</strong>
<ul>
<li>多路复用：QUIC支持多路复用，允许在同一个连接上同时进行多个数据流的传输，从而提高了网络的利用率和性能。</li>
<li>连接迁移：QUIC支持连接迁移，即在网络切换或IP地址变化时能够自动重新建立连接，而无需重新握手。</li>
<li>安全性：QUIC内置了加密机制，使得数据在传输过程中更加安全可靠，同时也能够防止中间人攻击等安全威胁。</li>
</ul>
</li>
</ul>
<p><strong>QUIC内置了加密机制，使得数据传输更加安全可靠，而KCP则需要在应用层实现相应的加密机制。</strong></p>
<h2 id="wafweb-application-firewall">WAF（Web Application Firewall）</h2>
<p>是一种网络安全工具，<strong>用于保护网络应用程序免受常见的网络攻击和漏洞利用</strong>。WAF通过<strong>检测和阻止恶意的HTTP/HTTPS流量</strong>，以及对应用程序层的攻击进行识别和防御，从而增强了网络应用程序的安全性。</p>
<h2 id="听说过graphql吗">听说过graphQL吗？</h2>
<p><strong>一种是前端需要更多的数据库权限，而且开发速度有要求，这样直接把操作数据库的权限放到前端。</strong></p>
<p>前端需要更多时间调整代码，并注意查询和操作数据库的可用性。</p>
<h2 id="bbr协议">BBR协议</h2>
<p>BBR最大的改进是由丢包率为主的有限状态机转为了由带宽时延积，（物理时延和带宽瓶颈）控制的状态机，走了两轮。<a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1482633" target="_blank" rel="noopener noreffer ">参见这个链接</a>[<a href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fdog250%2Farticle%2Fdetails%2F52879298" target="_blank" rel="noopener noreffer ">状态机，了解]</a></p>
<h2 id="http的keep-alive和tcp的keepalive">http的keep-alive和tcp的KeepAlive</h2>
<ul>
<li>TCP的<strong>keepalive</strong>是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次<strong>心跳</strong>包，<strong>如果间隔发送几次，对方都返回的是RST，或者没有响应，而不是ACK，那么就释放当前链接</strong>。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。</li>
<li>HTTP的<strong>keep-alive</strong>一般我们都会带上中间的横杠，主要功能是<strong>保活</strong>和<strong>复用</strong>。普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。<strong>但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话</strong>，两边对上暗号，这个连接就可以复用了，<strong>一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。</strong></li>
</ul>
<h2 id="已建立连接的tcp收到syn会发生什么">已建立连接的TCP，收到SYN会发生什么？</h2>
<ul>
<li><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong></li>
</ul>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>那旧连接里处于 Established 状态的服务端最后会怎么样呢？</p>
<p><strong>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。</strong></p>
<p>如果服务端一直没有发送数据包给客户端，在超过一段时间后，<strong>TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</strong></p>
<ul>
<li><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong></li>
</ul>
<p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p>
<p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p>
<h2 id="在-time_wait-状态的-tcp-连接收到-syn-后会发生什么">在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2>
<p><strong>收到合法 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p>
<p><strong>收到非法的 SYN</strong></p>
<p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p>
<h2 id="tcp-存在队头阻塞问题">TCP 存在队头阻塞问题</h2>
<p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。如下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/5a309f17f0182a816ddbc4cac4a5141e.gif"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/5a309f17f0182a816ddbc4cac4a5141e.gif, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/5a309f17f0182a816ddbc4cac4a5141e.gif 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/5a309f17f0182a816ddbc4cac4a5141e.gif 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/5a309f17f0182a816ddbc4cac4a5141e.gif"
        title="img" /></p>
<p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 <code>packet #3</code> 在网络中丢失了，即使 <code>packet #4-6</code> 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 <code>packet #3</code> 重传后，接收方的应用层才可以从内核中读取到数据。</p>
<p>这就是 TCP 队头阻塞问题，但这也不能怪 TCP ，因为只有这样做才能保证数据的有序性。</p>
<p><strong>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求，所以 HTTP/2 队头阻塞问题就是因为 TCP 协议导致的。</strong></p>
<p><strong>TCP 队头阻塞的问题，其实</strong>就是<strong>接收窗口的队头阻塞问题</strong>！！！！！！！</p>
<h2 id="如何基于-udp-协议实现可靠传输">如何基于 UDP 协议实现可靠传输？</h2>
<p><strong>TCP 协议四个方面的缺陷</strong>：</p>
<ul>
<li>升级 TCP 的工作很困难；</li>
<li>TCP 建立连接的延迟；</li>
<li>TCP 存在队头阻塞问题；</li>
<li>网络迁移需要重新建立 TCP 连接；</li>
</ul>
<p><strong>要基于 UDP 实现的可靠传输协议，那么就要在应用层下功夫</strong>，也就是要设计好协议的头部字段。</p>
<p><strong>quic协议的结构</strong></p>
<ul>
<li>先是udp的头部</li>
<li>然后是quic的packet的头部</li>
<li>最后是quic的frame的头部</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/72522dd50c22f5662c07f6a8ecc9197b.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/72522dd50c22f5662c07f6a8ecc9197b.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/72522dd50c22f5662c07f6a8ecc9197b.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/72522dd50c22f5662c07f6a8ecc9197b.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/72522dd50c22f5662c07f6a8ecc9197b.png"
        title="img" /></p>
<h3 id="packet-header">Packet Header</h3>
<p>Packet Header 首次建立连接时和日常传输数据时使用的 Header 是不同的。如下图（<em>注意我没有把 Header 所有字段都画出来，只是画出了重要的字段</em>）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f7eed932a3f2b867e04bfb4297dd5e43.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f7eed932a3f2b867e04bfb4297dd5e43.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f7eed932a3f2b867e04bfb4297dd5e43.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f7eed932a3f2b867e04bfb4297dd5e43.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/f7eed932a3f2b867e04bfb4297dd5e43.png"
        title="Packet Header" /></p>
<p><strong>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的</strong>，这样就能更加精确计算出报文的 RTT。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/8d5565d9c3efe331bb9fb8e8f2d09dac.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/8d5565d9c3efe331bb9fb8e8f2d09dac.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/8d5565d9c3efe331bb9fb8e8f2d09dac.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/8d5565d9c3efe331bb9fb8e8f2d09dac.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/8d5565d9c3efe331bb9fb8e8f2d09dac.png"
        title="img" /></p>
<p><strong>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</strong>（后面讲流量控制的时候，会举例子）</p>
<h3 id="quic-frame-header">QUIC Frame Header</h3>
<p>一个 Packet 报文中可以存放多个 QUIC Frame。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/ac87e9f1a26f40be280e62c1d5f3f8f6.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/ac87e9f1a26f40be280e62c1d5f3f8f6.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/ac87e9f1a26f40be280e62c1d5f3f8f6.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/ac87e9f1a26f40be280e62c1d5f3f8f6.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/ac87e9f1a26f40be280e62c1d5f3f8f6.png"
        title="img" /></p>
<p>每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。</p>
<p>Frame 格式，Stream 可以认为就是一条 HTTP 请求，它长这样：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/e420eb13ca194f7e657526eafe356c8b.png"
        data-srcset="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/e420eb13ca194f7e657526eafe356c8b.png, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/e420eb13ca194f7e657526eafe356c8b.png 1.5x, https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/e420eb13ca194f7e657526eafe356c8b.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/refs/heads/master/image/ad87d5897557f51a5da504aa51b4c283/e420eb13ca194f7e657526eafe356c8b.png"
        title="img" /></p>
<ul>
<li>Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li>
<li>Offset 作用：<strong>类似于 TCP 协议中的 Seq 序号</strong>，<strong>保证数据的顺序性和可靠性</strong>；</li>
<li>Length 作用：指明了 Frame 数据的长度。</li>
</ul>
<p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p>
<p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p>
<p><strong>为什么这样解决了TCP队头阻塞问题！！！！！！！</strong>，TCP队头阻塞主要是多个http公用一个tcp请求，一个steam阻塞导致所有的阻塞了。<strong>而quic不一样，它给每个steam都分配了一个独立的滑动窗口</strong>。<strong>这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p>
<p><strong>quic的机制</strong></p>
<ul>
<li>滑动窗口</li>
<li>流量控制，通过几个参数</li>
<li>拥塞控制。</li>
</ul>
<p><strong>QUIC的TLS</strong></p>
<p><strong>TCP的缺点</strong>：TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手（1RTT），再 TLS 握手（2RTT），所以需要 3RTT 的延迟才能传输数据，就算 Session 会话服用，也需要至少 2 个 RTT。</p>
<p><strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p>
<h2 id="tcp-和-udp-可以同时绑定相同的端口吗">TCP 和 UDP 可以同时绑定相同的端口吗？</h2>
<p><strong>可以的。</strong></p>
<p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p>因此， TCP/UDP 各自的端口号也相互独立，互不影响。</p>
<h2 id="一个数据包在网络中的发送过程">一个数据包在网络中的发送过程</h2>
<p>客户端-》交换机-》路由器</p>
<p>注意：从客户端出发的时候是内网ip，<strong>在路由器可能会执行网络地址转换（NAT）将内网的私有IP地址转换为路由器的公网IP地址。当数据包从客户端发送到服务器时，路由器会将源IP地址修改为其自身的公网IP地址，它会在NAT转换表中记录这个映射关系，以便在响应数据包到达时进行逆向转换。（这也是数据包能够回传的重要原因）</strong></p>
<p>然后路由器根据自身的路由表一个一个传递。</p>
<p>-》到达服务器，<strong>服务器拆包，然后发送回nat出来的对应的运营商的公网ip</strong>。</p>
<p>-》<strong>nat映射到内网，发送到指定的客户端</strong>。</p>
<h1 id="rpc与proto协议">RPC与proto协议</h1>
<p><strong>Protocol Buffers（通常简称为protobuf）是Google开发的一种数据序列化协议（类似于XML、JSON、YAML等），它能将结构化数据序列化，用于数据存储、通信协议等方面。</strong></p>
<p>protobuf的主要优点是：</p>
<ol>
<li><strong>紧凑：protobuf序列化后的数据非常小，比XML、JSON等格式更加紧凑。</strong></li>
<li><strong>高效：protobuf的序列化和反序列化速度非常快。</strong></li>
<li>强类型：protobuf的数据是强类型的，可以明确数据的类型。</li>
<li>语言无关：<strong>protobuf支持多种编程语言</strong>，如Java、C++、Python等。</li>
<li>向后兼容：protobuf定义的消息格式可以方便地进行升级，新旧版本的消息格式可以兼容。</li>
</ol>
<p>下面是一个protobuf的使用示例：</p>
<p>首先，定义一个protobuf的消息格式（保存为<code>person.proto</code>文件）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-protobuf" data-lang="protobuf"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">Person</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">email</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后，使用protobuf的编译器（<code>protoc</code>）生成对应语言的代码，例如生成Python代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">protoc --python_out<span class="o">=</span>. person.proto
</span></span></code></pre></td></tr></table>
</div>
</div><p>这将生成一个<code>person_pb2.py</code>文件，里面包含了<code>Person</code>类的定义。</p>
<p>接下来，就可以在Python代码中使用<code>Person</code>类进行序列化和反序列化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">person_pb2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个Person对象</span>
</span></span><span class="line"><span class="cl"><span class="n">person</span> <span class="o">=</span> <span class="n">person_pb2</span><span class="o">.</span><span class="n">Person</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;Alice&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">123</span>
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&#34;alice@example.com&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 序列化</span>
</span></span><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 反序列化</span>
</span></span><span class="line"><span class="cl"><span class="n">new_person</span> <span class="o">=</span> <span class="n">person_pb2</span><span class="o">.</span><span class="n">Person</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">new_person</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">new_person</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_person</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">new_person</span><span class="o">.</span><span class="n">email</span><span class="p">)</span>  <span class="c1"># 输出 &#34;Alice 123 alice@example.com&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，我们首先创建了一个<code>Person</code>对象，并赋值。然后，我们将<code>Person</code>对象序列化为一个字符串。接着，我们创建了一个新的<code>Person</code>对象，并从字符串中反序列化。最后，我们打印出反序列化后的数据，可以看到数据是正确的。</p>
<h1 id="cgi和wsgi">CGI和WSGI</h1>
<p>CGI是<strong>通用网关接口</strong>，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。 CGI程序是一个独立的程序，它<strong>可以用几乎所有语言来写，包括perl，c，lua，python等等</strong>。</p>
<p>WSGI, Web Server Gateway Interface，<strong>是Python应用程序或框架和Web服务器之间的一种接口</strong>，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<h1 id="c10k问题">c10k问题</h1>
<p>C10K问题是指<strong>服务器同时处理大量（例如：上万，即10K）客户端连接的问题</strong>。这个问题在1999年由Dan Kegel首次提出，当时的很多服务器软件在面对大量并发连接时会出现各种问题，如性能下降，无法处理更多的连接等。</p>
<p><strong>C10K问题的解决方法主要涉及到操作系统级别的网络编程模型优化，如使用事件驱动（event-driven）或异步I/O（asynchronous I/O）模型，以及使用更现代的多线程或多进程模型等。</strong></p>
<p>现在，很多现代的Web服务器和操作系统（如Nginx，Linux等）已经可以很好地处理C10K问题，能够支持上万甚至更多的并发连接。</p>
<h1 id="tcp同时打开和同时关闭">TCP同时打开和同时关闭</h1>
<h3 id="1-同时打开">1. 同时打开</h3>
<p>两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口最为本地端口。
当出现同时打开的情况时，状态迁移图就与标准的连接状态迁移图不一样了。两端几乎同时发送SYN并进入SYN_SENT状态。当每一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。当双方都接收到SYN及相应的ACK时，状态都变味了ESTABLISHED。
一个同时打开的连接需要交换需要交换4个报文段，比正常的三次握手多一个。没有任何一端称为客户或服务器，因为每一端既是客户又是服务器。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img-blog.csdn.net/20170704164020832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"
        data-srcset="https://img-blog.csdn.net/20170704164020832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast, https://img-blog.csdn.net/20170704164020832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 1.5x, https://img-blog.csdn.net/20170704164020832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 2x"
        data-sizes="auto"
        alt="https://img-blog.csdn.net/20170704164020832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"
        title="img" /></p>
<h3 id="2-同时关闭">2. 同时关闭</h3>
<p>在标准的情况下通过一方发送FIN来关闭连接，但是双方都执行主动关闭也是有可能的，TCP协议也允许这样的同时关闭。当应用层发出关闭命令时，梁福安均从ESTABLISHED变为FIN_WAITE_1。这将导致双发各发送一个FIN，两个FIN经过网络传输后分别达到另一端。收到FIN后，状态由FIN_WAIT_1变签到CLOSING，并将发送最后的ACK。当收到最后的ACK时，状态变化为TIME_WAIT。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img-blog.csdn.net/20170704164028654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"
        data-srcset="https://img-blog.csdn.net/20170704164028654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast, https://img-blog.csdn.net/20170704164028654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 1.5x, https://img-blog.csdn.net/20170704164028654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 2x"
        data-sizes="auto"
        alt="https://img-blog.csdn.net/20170704164028654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbV9idWRkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"
        title="img" /></p>
<h1 id="ref">ref</h1>
<p><a href="https://cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.html" target="_blank" rel="noopener noreffer ">cs-note</a></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-08-22</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-title="计算机网络" data-hashtags="计算机网络"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-hashtag="计算机网络"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-title="计算机网络"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-title="计算机网络"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://kengerlwl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-title="计算机网络"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E7%AE%80%E5%8E%86%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" class="prev" rel="prev" title="简历自我介绍"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>简历自我介绍</a>
            <a href="/%E5%85%B6%E4%BB%96/" class="next" rel="next" title="计算机操作系统">计算机操作系统<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="giscus" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://giscus.app">Giscus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.132.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://kengerlwl.github.io/" target="_blank">kenger</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"giscus":{"category":"Announcements","categoryId":"DIC_kwDOFA4dBM4Ce_0B","darkTheme":"github-dark","emitMetadata":"0","inputPosition":"bottom","lang":"zh-CN","lazyLoading":false,"lightTheme":"github-light","mapping":"pathname","reactionsEnabled":"1","repo":"kengerlwl/kengerlwl.github.io","repoId":"MDEwOlJlcG9zaXRvcnkzMzY0NjkyNTI="}},"search":{"algoliaAppID":"JCTYUNKA9R","algoliaIndex":"kenger","algoliaSearchKey":"3ef68664495033362b7df9cf5a3eee1e","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
