---
title: 大模型缓存命中原理
top: false
cover: false
toc: true
mathjax: true
date: 2026-01-20 15:27:31
password:
summary:
tags:
- 缓存
- 推理
- LLM
categories:
- 学术
---

# 大模型的缓存命中机制：为什么我改了最后一条消息还会命中？

很多人在用大模型时都会遇到一个现象：

> 明明改了最后一条 message 的内容，为什么系统还显示“缓存命中”？

要理解这一点，先弄清楚：**系统到底在“缓存”什么？**

---

## 一、几种常见的缓存类型

在大模型服务里，一般至少会有这几类缓存机制：

### 1. 请求级缓存（API 层）

- 按**整个请求**做缓存  
- 模型、参数、完整 prompt 都一致，才算命中  
- 特点：只要你改任何一个字，理论上就**不会命中**  
- 常用于“完全相同请求 → 直接返回上次结果”

### 2. 上下文 KV 缓存（模型内部）

- 按**token 序列**做缓存  
- 模型会把前面已经算过的 token 的 Key/Value 状态存起来，下次复用  
- 只要**前面的内容不变**，哪怕最后一条 message 改了，前半段还是可以复用  
- 所以会出现这种情况：  
  - 日志里看起来“命中缓存”  
  - 但实际输出还是会随着你修改最后一句而变化  
- 本质是：**前文命中，最后一段重算**



### 只改system前面内容

**经过我的测试，改动了system prompt后。**
经过测试，在我修改了system prompt后，也就是改变了第一条消息，cache_write_tokens很大，而cache_read_tokens则很小，代表没有命中缓存，反而往缓存里面写入了大量信息

```
    "usage": {
        "completion_tokens": 90,
        "prompt_tokens": 5,
        "total_tokens": 95,
        "cache_write_tokens": 69127,
        "cache_read_tokens": 0,
        "input_tokens": 0,
        "output_tokens": 0
    },
```

### 只改lastMessage内容

可以看到缓存仍然能命中

```
    "usage": {
        "completion_tokens": 1303,
        "prompt_tokens": 6,
        "total_tokens": 1309,
        "cache_write_tokens": 184,
        "cache_read_tokens": 68769,
        "input_tokens": 0,
        "output_tokens": 0
    },
```



### 3. 语义缓存 / Embedding 缓存（部分平台）

- 按语义相似度缓存，而不是按字面一致  
- “看起来差不多”的问题可能被认为可以复用  
- 多见于知识库问答、检索增强（RAG）场景  
- 通常会直接重用之前的最终回答
