---
title: 数据库原理
top: false
cover: false
toc: true
mathjax: true
date: 2024-03-12 15:27:31
password:
summary:
tags:
- 数据库
categories:
- find JOB

---



## 事务



事务指的是**满足 ACID 特性的一组操作**，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

### ACID

#### 1. 原子性（Atomicity）
事务被视为不可分割的最小单元，**事务的所有操作要么全部提交成功，要么全部失败回滚。**

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 2. 一致性（Consistency）
**数据库在事务执行前后都保持一致性状态**。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

#### 3. 隔离性（Isolation）
**一个事务所做的修改在最终提交以前，对其它事务是不可见的。**

#### 4. 持久性（Durability）
**一旦事务提交，则其所做的修改将会永远保存到数据库中。**即使系统发生崩溃，事务执行的结果也不能丢失。

### 并发一致性问题

#### 丢失修改（同时修改被覆盖）
指一个事务的更新操作被另一个事务的更新操作替换。常见情况是一个事务先提交，然后另一个事务覆盖了它的修改。

#### 读脏数据（读一次读到了一个失败的write的脏数据）
在不同的事务下，当前事务可以读取到另一个事务未提交的数据，导致读取到的数据不准确。

#### 不可重复读（多次读，读到了一个成功的write的前后两次数据）
**在一个事务内多次读取同一数据集合**，但在事务结束前，另一个事务修改了数据，导致多次读取结果不一致。

#### 幻影读（针对的集合等类型（属性变化）的不可重复读）
类似于不可重复读，但是是针对数据集合范围的操作。一个事务读取某个范围的数据，另一个事务在该范围内插入新数据，导致第一次和第二次读取结果不同。

并发不一致性问题的主要原因是事务隔离性的破坏，解决方法包括通过并发控制和事务隔离级别来保证数据的一致性。





## 锁

 ###  粒度

MySQL 中提供了两种封锁粒度：**行级锁以及表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。**

### 封锁类型

#### 读写锁
- X 锁（Exclusive）：又称写锁，允许对数据对象进行读取和更新操作，**期间其他事务不能对该数据对象加锁。**
- S 锁（Shared）：又称读锁，**允许对数据对象进行读取操作，但不允许更新操作**，**期间其他事务可以对该数据对象加 S 锁，但不能加 X 锁。**

#### 意向锁
意向锁（Intention Locks）支持多粒度封锁，引入了 IX/IS 锁。
- IS 锁：表示事务想要在表中的某个数据行上加 S 锁。
- IX 锁：表示事务想要在表中的某个数据行上加 X 锁。

意向锁的引入简化了对表级封锁的管理，使得事务能够更高效地加锁。

#### 乐观锁与悲观锁

 - **悲观锁**：认为数据在并发环境下会发生冲突，因此在读取数据时会先加锁，确保其他事务无法修改数据，直到当前事务完成操作。 
 -  **乐观锁**：认为数据在大多数情况下不会发生冲突，所以在操作数据时不加锁，而是在更新数据时检查是否有其他事务对数据进行了修改，若无修改则更新成功，否则进行相应的处理。 



## 隔离级别(两提两可)

**未提交读 (READ UNCOMMITTED)**
修改在事务中即使未提交，也对其他事务可见。

**提交读 (READ COMMITTED)**
事务只能读取已提交的修改，未提交的修改对其他事务不可见。

**可重复读 (REPEATABLE READ)**
同一事务中多次读取数据结果一致。

**可串行化 (SERIALIZABLE)**
强制事务串行执行，防止并发一致性问题，需加锁实现。

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/45294bb9d60cfc2b07ffb63f8c3b4538.png)





## 多版本并发控制 (MVCC)

**基本思想**

背景：**在实际场景中读操作往往多于写操作**，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，**写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。**

**在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。**

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读

MVCC （Multi-Version Concurrency Control, MVCC）利用多版本的思想，通过快照来实现并发控制，避免了不必要的加锁操作。事务的修改操作会为数据行创建新的版本快照，而读操作则可以读取旧版本快照。

**版本号**

**系统版本号 SYS_ID 是递增的**，每个事务开始时都有一个事务版本号 TRX_ID，记录在 Undo 日志中。

**Undo 日志**

Undo 日志存储了数据行的多个版本快照，通过回滚指针将它们连接起来。INSERT、UPDATE、DELETE 操作都会创建日志，并记录事务版本号。

**ReadView**

MVCC 维护了一个 ReadView 结构，包含了当前系统未提交的事务列表和最小、最大事务版本号。在进行 SELECT 操作时，根据快照的事务版本号和 ReadView 进行判断，决定是否可以使用该快照。

**快照读与当前读**

**SELECT 操作是快照读，不需要加锁**；读取某个时间节点的数据

**而INSERT、UPDATE、DELETE 操作需要加锁，以读取最新数据。**读取最新的







# 关系数据库



### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

**如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。(Primary Key)**

**对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。**

**对于 A->B，B->C，则 A->C 是一个传递函数依赖**

### 范式

范式理论旨在解决数据库中的异常情况，其中高级别的范式依赖于低级别的范式。第一范式是最低级别的范式。

##### 第一范式 (1NF)
属性不可再分。

##### 第二范式 (2NF)
每个非主属性完全依赖于键码。（就是非主属性完全依赖于主关键字。）

可以通过分解表来解决

##### 第三范式 (3NF)** **[ 消除传递依赖 ]****
非主属性不传递依赖于键码。

**需要注意的是，可以通过分解关系来满足第二范式和第三范式的要求。**



