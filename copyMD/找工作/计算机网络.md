---
title: 计算机网络
top: false
cover: false
toc: true
mathjax: true
date: 2023-08-22 15:27:31
password:
summary:
tags:
- 计算机网络
categories:
- find JOB
---





# 概述



## ISP

互联网服务提供商 ISP



## 主机之间的通信方式

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/167228b3fa90b50063dee6ac4ac7cdc7.png)



- 对等（P2P）：不区分客户和服务器。

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/a1ca5d1396168515e38608f4a4f75bff.png)

## 互联网上的数据传输模式：

**分组交换**：每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，**因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。**

## 计算机网络体系结构

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/93f7a785132067fcfa6d94bfb65002b6.png)



### 五层协议

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。**数据单位为报文**。
- **传输层（进程）** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：**传输控制协议 TCP**，提供面向连接、可靠的数据传输服务，数据单位为报文段；**用户数据报协议 UDP**，提供无连接、尽最大努力的数据传输服务，**数据单位为用户数据报**。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层（主机ip）** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封**装成分组**。
- **数据链路层（mac地址）** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组**封装成帧**。
- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

### OSI

五层协议的复杂版，多了表示层和会话层，

### TCP/IP

它只有四层，相当于五层协议中**数据链路层和物理层（最下面两层）合并为网络接口层。**

TCP/IP 体系结构不**严格遵循 OSI 分层概念**，应用层可能会直接使用 IP 层或者网络接口层。

### 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。（**越往下，越封装一层**）



# 物理层

## 通信方式

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

# 链路层

## 基本功能

- **数据帧的传输：** 链路层负责将网络层的数据包封装成数据帧，以便在物理介质上进行传输。
- **介质访问控制：** 链路层通过介质访问控制（MAC）协议来管理共享介质上的数据传输
- 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。

## 信道分类

1. **广播信道：** 允许一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。需要专门的控制方法进行协调，避免碰撞。常见的控制方法包括信道复用技术和CSMA/CD协议。
2. **点对点信道：** 适用于一对一通信，不会发生碰撞，使用简单的PPP协议进行控制。

## 信道复用技术

1. **频分复用（FDM）：** 将通信**频段划分**为多个不重叠的子频段，每个用户或信道占据一个特定的频段进行通信。常见于无线电通信和有线电视系统。

2. **时分复用（TDM）：** 将通信**时间段划分**为若干个固定长度的时隙，不同用户或信道在不同时隙内进行通信。常见于数字通信系统和电话网络。

3. **码分复用（CDM）：** 将**数据通过不同的编码方案进行调制**，然后同时发送到通信媒介上。接收端使用相应的解码方案来提取目标数据。常见于CDMA（Code Division Multiple Access）系统。

4. 统计时分复用

   是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。
5. 统计时分复用

   是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

这些信道复用技术**使得多个用户能够共享同一通信媒介，从而实现了高效的通信**。

## CSMA/CD 协议

CSMA/CD 表示载波监听多点接入 / 碰撞检测。

- **多点接入** ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
- **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

## PPP 协议

互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，**PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。**

## MAC 地址

MAC 地址是**链路层地址，长度为 6 字节（48 位，共2*6个字母数字表示），用于唯一标识网络适配器（网卡）**。（可以有虚拟网卡）



## 交换机

交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。

## 虚拟局域网VLAN（处于链路层）

**交换机通过在数据帧中标记 VLAN ID 来实现逻辑上的隔离，**使得不同 VLAN 的设备能够彼此通信，但在逻辑上却处于不同的虚拟网络中。

虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。





# 网络层

网络层是整个**互联网的核心**，因此应当让网络层尽可能简单。**网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。**

这一层的链接用的**IP地址**



## IP 地址编址方式

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

## 地址解析协议 ARP

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在**通信过程中，IP 数据报的源地址和目的地址始终不变**，而 **MAC 地址随着链路的改变而改变**。

**为了应对MAC地址变换，ARP 实现由 IP 地址得到 MAC 地址。**

**每个主机都有一个 ARP 高速缓存**，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。`arp -a`命令可以查看该映射表（向网络发送一个ARP请求的广播包）

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。（**简单来说，就是通过arp请求获取到指定ip的mac地址**）

## 网际控制报文协议 ICMP（挺重要）

ICMP（Internet Control Message Protocol）是一种网络协议，用于**在IP网络上发送控制消息**。它通常用于诊断网络故障、执行网络管理任务和提供错误报告。ICMP消息通常被内置在IP数据包中，以便在网络中传输。

### Ping

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率

（**如果在交换机禁止ICMP嗅探会怎么样：无法使用ICMP工具（例如ping）来测试网络设备之间的连通性和延迟。**）



### Traceroute

**(用于查看数据包跳了哪些点)**

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。



## 虚拟专用网 VPN

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255 **通常被用于大型组织或企业内部的网络**
- 172.16.0.0 ~ 172.31.255.255 **中型到大型组织的内部网络。**
- 192.168.0.0 ~ 192.168.255.255 **家庭网络或小型办公室的内部网络**



## 网络地址转换 NAT

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。（**主要是ipv4没有那么多ip。**）



## 路由器分组转发流程（这个我比较熟）

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。





# 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。

**传输层提供了进程间的逻辑通信，**

## UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是**无连接的**，尽最大可能交付，没有拥塞控制，**面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），**支持一对一、一对多、多对一和多对多的交互通信。**
- 传输控制协议 TCP（Transmission Control Protocol）是**面向连接的**，提供**可靠交付**，有流量控制，拥塞控制，提供全双工通信，**面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。**

- **UDP如何变得可靠**：等待确认+超时重传+编号
  - UDP要想可靠，就要接收方收到UDP之后回复个确认包，**发送方有个机制，收不到确认包就要重新发送**，**每个包有递增的序号，接收方发现中间丢了包就要发重传请求**，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。





## TCP 首部格式（flags标志）

- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
- **RST** ，重置指令，表示出现严重错误，常用于拒绝非法报文段以及拒绝连接请求；

## TCP 的三次握手

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/581452ee8c6e16e4026d922db86cea5c.png)

**① SYN(synchronous建立联机)；**

**② ACK(acknowledgement 确认)**

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

(简单来说，就是客户端先向服务器端发送请求，表示发起连接（SYN码为1），服务器端收到后，同意建立连接（ACK为1），然后发送响应给客户端，告知自己OK了，然后客户端接受到消息，确认服务器OK后。发送消息告诉客户端自己也OK（ACK为1），到这里，服务器和客户端都确认对方OK能收发消息，开始通信。)

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

1. **建立可靠的连接：** 三次握手确保了客户端和服务器端在同一个初始序列号下建立连接，从而避免了可能出现的混乱和数据混乱。
2. **防止旧连接的重新建立：** 由于每次连接建立都会使用不同的初始序列号，因此可以防止旧的连接被重新建立，从而增强了连接的安全性。
3. **减少不必要的资源占用：** 如果客户端发送的连接请求在网络中因某些原因丢失，服务器将不会收到该请求，从而避免了不必要的资源占用和连接建立失败。


### 第一次握手丢失
就会触发超时重传机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

> **当第五次超时重传后**，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。


### 第二次握手丢失

> - **客户端会重传 SYN 报文，也就是第一次握手**，最大重传次数由 `tcp_syn_retries`内核参数决定；
> - **服务端会重传 SYN-ACK 报文，也就是第二次握手**，最大重传次数由 `tcp_synack_retries` 内核参数决定

### 第三次握手丢失
如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，**重传 SYN-ACK 报文（也就是第二次握手）**，直到收到第三次握手，或者达到最大重传次数。






## TCP 的四次挥手

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/55a478fca6881d2d9232bac974fea810.png)



以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，**FIN=1**。
- B 收到之后发出确认，此时 TCP **属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。**
- **当 B 不再需要连接时，发送连接释放报文，FIN=1。**
- A 收到后发出确认**ACK=1**，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接**ACK=1**。

**四次挥手的原因**

 **CLOSE-WAIT** 

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 **CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。**（主要是怕服务器端没有收到然后重发消息给客户端）
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。





## TCP沾包和拆包

TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题

**为什么会产生粘包和拆包呢?**

- 要发送的数据**小于TCP发送缓冲区的大小**，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- **接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包**；
- 要**发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包**；
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MS



## TCP的流量控制

> TCP 提供一种机制可以**让发送端根据接收端的实际接收能力控制发送的数据量**，这就是**流量控制**



## TCP 可靠传输

**TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。**



## TCP 滑动窗口

**窗口是缓存的一部分，用来暂时存放字节流**。**发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。**

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。



## TCP 流量控制

**流量控制是为了控制发送方发送速率，保证接收方来得及接收。**

**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小**，从而影响发送方的发送速率（**可以通过滑动窗口设置流量大小**）。将窗口字段设置为 0，则发送方不能发送数据。

## TCP 拥塞控制（先慢+拥塞避免（指数到线性），再快重传并恢复。）

**如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。**因此当出现拥塞时，**应当控制发送方的速率**。这一点和流量控制很像，但是出发点不同。**流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度**。

**原理：**

------

为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念

**拥塞窗口 cwnd**是**发送方维护的一个的状态变量**，它会根据**网络的拥塞程度动态变化的**。

拥塞窗口 `cwnd` 变化的规则：

- 只要网络中**没有出现拥塞，`cwnd` 就会增大**；
- 但网络中**出现了拥塞，`cwnd` 就减少**

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞

-----

**前置声明：超时重传。**

> 其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞**

![TCP的拥塞控制](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-congestion-control.png)

**慢开始（Slow Start）和拥塞避免（Congestion Avoidance）是 TCP 拥塞控制的两个关键机制。**

1. **慢开始（Slow Start）**：在开始发送数据时，TCP 发送方会以较小的拥塞窗口大小开始发送数据。随着时间的推移和收到确认的数据包数量的增加，**发送方会逐渐增加拥塞窗口的大小，指数级增长**，以便测试网络的容量。**如果没有发生丢包，拥塞窗口大小会快速增长，直到达到一个阈值（慢开始阈值）**。
2. **拥塞避免（Congestion Avoidance）**：**一旦拥塞窗口大小达到了慢开始阈值**，TCP 发送方就会**进入拥塞避免阶段**。在这个阶段，**拥塞窗口的增长变得线性**，而不是指数增长。**这样做是为了避免过快地增加发送的数据量，从而导致网络拥塞。**

**快重传（Fast Retransmit）和快恢复（Fast Recovery）则是 TCP 在检测到丢失数据包时的一种快速恢复机制。**

1. **快重传（Fast Retransmit）**：当**发送方连续收到三个相同的确认 ACK 时，它会认为有一个分组丢失，并立即重传这个分组，而不用等待超时**。
2. **快恢复（Fast Recovery）**：在进行快重传后，**TCP 发送方不会立即进入慢开始阶段，而是将拥塞窗口减半，然后进入快恢复状态**。在快恢复状态下，**拥塞窗口大小会增加，并且继续线性增长而不是指数增长**。这样可以更快地恢复到之前的发送速率。



# 应用层



## DNS

DNS 是一个**分布式数据库**，提供了主机名和 IP 地址之间相互转换的服务。



**DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，**这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）

 

## 文件传送协议

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：服务器端使用21端口

## 动态主机配置协议

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 工作过程如下：

1. **客户端发送 Discover 报文**，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 **UDP 中，该报文被广播到同一个子网的所有主机上（UDP支持点对多，TCP只能点对点）**。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. **DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端**，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。



## 远程登录协议

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。

## 电子邮件协议

一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。





### socket接口（并不是协议）

Socket 不是一个严格意义上的网络层或协议，而是一个应用程序接口（API）层。因此，Socket 位于 OSI 模型的最顶层——应用层，用于帮助应用程序与传输层（如 TCP 和 UDP）进行通信。TCP与UDP都行



# 其他综合网络题目



## 从浏览器地址栏输入url到显示主页的过程？

> 1. 浏览器通过域名查找对应的ip地址
>    1. DNS
> 2. 浏览器与服务器通过三次握手建议TCP连接
> 3. 浏览器向服务器发送一个HTTP请求
> 4. 服务器处理请求（处理请求参数、cookie，生成HTML响应）
> 5. 服务器返回一个HTML响应
> 6. 浏览器解析渲染页面
> 7. TCP四次挥手，结束





## HTTP1.0,1.1,2.0

> 简化版区别：
>
> HTTP/1.0：默认是短连接，**可以强制开启，通过加入Connection: keep - alive**
>
> - 默认使用**短连接**，**每次请求都需要建立一个TCP连接**
>
> HTTP/1.1：默认为长连接
>
> - 最主要的改进就是引入了持久连接。所谓的持久连接即**TCP连接默认不关闭，可以被多个请求复用**
> - 引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率
>
> HTTP/2.0：多路复用
>
> - **多路复用：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应**，而且不用按照顺序一一对应
> - **做了Header压缩**、服务端推送等优化
>
> HTTP/3.0：基于UDP的quic协议。



## HTTPS的加密流程是怎样的？

> 1. 发起请求（TCP链接）： 客户端在通过TCP 和服务器建立连接之后（ 443 端口），发出一个请求证书的消息给服务器，在该请求消息里包含自己可实现的算法列表和其他需要的消息。
> 2. 证书返回：服务器端在收到消息后回应客户端并返回证书，在**证书中包含服务器信息、域名、申请证书的公司、公钥、数据加密算法等。**
> 3. 证书验证： **客户端在收到证书后，判断证书签发机构是否正确**，并使用该签发机构的公钥确认签名是否有效， 客户端还会确保在证书中列出的域名就是它正在连接的域名。如果客户端确认证书有效，则生成对称密钥，并使用公钥将对称密钥加密。
> 4. 密钥交换： **客户端将加密后的对称密钥发送给服务器**，服务器在接收到对称密钥后使用私钥解密
> 5. 数据传输： 经过上述步骤，客户端和服务器就完成了密钥对的交换， 在之后的数据传输过程中， 客户端和服务端就可以基于对称加密（ 加密和解密使用相同密钥的加密算法）对数据加密后在网络上传输，保证了网络数据传输的安全性
>
> **总结：实际上是一种混合加密，通过非对称加密交换了对称加密的对称秘钥**，实现了安全性和性能的综合



## TCP 和 UDP 分别对应的常见应用层协议有哪些？

> **基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**
>
> - **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口80
> - **FTP**: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)
> - **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25
> - **TELNET**: Teletype over the Network (网络电传), 默认端口23
> - **SSH**：Secure Shell（安全外壳协议），默认端口 22
>
> **基于UDP的应用层协议：DNS、TFTP、SNMP**
>
> - **DNS** : Domain Name Service (域名服务),默认端口 53
> - **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69
> - **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162



## HTTP缓存有哪些？

> - 强制缓存：只要**浏览器判断缓存没有过期，则直接使用浏览器的本地缓存**，决定是否使用缓存的主动性在于浏览器这边，（检测到一样的请求链接，在过期时间内，直接访问本地缓存结构，不发送http请求）
> - 协商缓存：通过服务端告知客户端是否可以使用缓存的方式，**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**



## 如何在 Linux 系统中查看 TCP 状态？

> TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看
>
> ![TCP 连接状态查看](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/ad87d5897557f51a5da504aa51b4c283/f1193ff8b388617c0de6badda63473af.png)





## 说说HTTP常用的状态码及其含义？

| 状态码 | 类别             |
| ------ | ---------------- |
| 1XX    | 信息性状态码     |
| 2XX    | 成功类状态码     |
| 3XX    | 重定向状态码     |
| 4XX    | 客户端错误状态码 |
| 5XX    | 服务端错误状态码 |







## HTTP和RPC

**HTTP** 协议（**H**yper **T**ext **T**ransfer **P**rotocol），又叫做**超文本传输协议**。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。

而 **RPC**（**R**emote **P**rocedure **C**all），又叫做**远程过程调用**。它本身并不是一个具体的协议，而是一种**调用方式**。（远程调用其他服务的函数，比较有名的`gRPC`，`thrift`。）（RPC必http早）。RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。

由于RPC可以自己根据需求研发，可以实现根据一些内部服务需求做性能上的优化。





## HTTP缓存有哪些？（强制缓存和协商缓存）

> - 强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边
> - 协商缓存：通过服务端告知客户端是否可以使用缓存的方式，**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**



















# ref



[cs-note](https://cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.html)
