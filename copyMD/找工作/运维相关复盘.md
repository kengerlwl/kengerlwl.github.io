---
title: 运维相关复盘
top: false
cover: false
toc: true
mathjax: true
hidden: true
date: 2024-04-11 15:27:31
password:
summary:
tags:
- 运维
categories:
- find JOB

---





# OOM内存溢出问题





## java程序内存溢出问题



**jvm 配置常见参数:**

 **堆参数参数**

| 参数              | 描述                                                    |
| ----------------- | ------------------------------------------------------- |
| **-Xms**          | 设置 JVM启动时堆内存的初始化大小                        |
| **-Xmx**          | 设置堆内存最大值                                        |
| -Xmn              | 设置年轻代的空间大小,剩下的为年老代的空间大小           |
| -XX:PermGen       | 设置永久代的内存初始化大小(JDK1.8 开始废弃永久代)       |
| -XX:MaxPermGen    | 设置永久代的最大值                                      |
| -XX:SurvivorRatio | 设置Eden区和Survivor区的空间比例:Eden/S0 =Eden/S1 默认8 |
| -XX:NewRatio      | 设置年老代和年轻代的比例大小,默认值是2                  |



**内存堆dump** 

5.使用 **jmap** -dump:format=b,file=heap.log pid **保存了堆现场，然后重启了应用服务**

堆文件都是一些二进制数据，在命令行查看非常麻烦，Java 为我们提供的工具都是可视化的，Linux 服务器上又没法查看，那么首先要把文件下载到本地。

由于我们设置的堆内存为 4G，所以 dump 出来的堆文件也很大，下载它确实非常费事，不过我们可以先对它进行一次压缩。

然后，借助内存分析工具**MAT**(Memory Analyzer Tool)：可以查看到是哪个对象导致了导量的堆占用

# CPU占用飙高问题

## java程序高占用

```
public class JStackDemo {

    public static void main(String[] args) {
        int a = 10;
        while (true) {
            a = 100;
        }
    }
}
```

**先查询PID和计算PID的16进制**



**第二步使用jstack得到线程堆栈信息**

> 使用jstack pid |grep tid查看线程堆栈信息，并且输出到jstack.log文件中

```
jstack 2552 |grep 9f9 -A 30 > jstack.log
```

**分析线程堆栈信息**

> 此时应该得到了一个jstack.log的堆栈日志文件.
>
> 分析具体代码逻辑，溯源

```powershell
cat jstack.log

"main" #1 prio=5 os_prio=0 tid=0x00007f3f8004b800 nid=0xa50 runnable [0x00007f3f86ee8000]
   java.lang.Thread.State: RUNNABLE
	at JStackDemo.main(JStackDemo.java:6)

"VM Thread" os_prio=0 tid=0x00007f3f800cb800 nid=0xa51 runnable 

"VM Periodic Task Thread" os_prio=0 tid=0x00007f3f8011d000 nid=0xa58 waiting on condition 

JNI global references: 5
```



# 一个程序基本的内存结构

一个程序的基本内存结构通常包括堆（Heap）、栈（Stack）以及代码区（Code Area）和静态区（Static Area）。

1. **堆（Heap）**：堆是程序运行时动态分配内存的区域，用于存储对象实例和数组等动态分配的数据。堆是由垃圾收集器（Garbage Collector）管理的，它负责在不再需要时回收对象的内存空间。在Java中，所有通过 `new` 关键字创建的对象都存储在堆中。
2. **栈（Stack）**：栈是程序运行时的一种数据结构，用于存储方法的调用栈和局部变量。每当调用一个方法时，都会在栈上创建一个对应的栈帧（Stack Frame），栈帧包含了方法的参数、局部变量以及方法返回的地址等信息。当方法执行完毕时，对应的栈帧会被弹出栈。栈是线程私有的，每个线程都有自己的栈。
3. **代码区（Code Area）**：代码区存储程序执行的字节码指令，包括所有的方法和函数代码。在Java中，字节码被加载到代码区，并由JVM执行。
4. **静态区（Static Area）**：静态区存储类的静态变量、常量、类信息等。静态区在程序启动时被分配，并且在整个程序生命周期内存在。



# 业内常用的分布式数据库

1. **MongoDB**：一种文档型数据库，可水平扩展，适用于大规模应用和复杂的数据结构。
2. **Cassandra：一个高度可扩展的分布式数据库，适用于大规模数据的分布式存储和处理。**
3. **Redis**：一个支持多种数据结构的内存数据库，可以用作缓存和消息传递系统。
4. **Apache HBase：基于Hadoop的分布式数据库，适用于大规模结构化数据的存储和实时查询。**
5. **Amazon DynamoDB**：一种托管的NoSQL数据库服务，具有高可用性和可伸缩性。
6. **Google Cloud Spanner：一种全球分布式的关系型数据库服务，提供了ACID事务和水平扩展的能力。**
7. **Apache Kafka**：一种分布式流处理平台和消息队列系统，用于实时数据流处理。
8. **Apache CouchDB**：一种面向文档的NoSQL数据库，具有分布式特性和支持数据同步。
9. **TiDB**：一个开源的分布式SQL数据库，兼容MySQL协议，适用于OLTP和OLAP场景。
10. **Neo4j**：一个图形数据库，用于存储和处理具有复杂关系的数据，例如社交网络和推荐系统。





# 常用运维命令



1. **iftop**：`iftop` 是一个命令行工具，用于实时显示**网络接口上的带宽使用情**况。它以类似于 "top" 的方式显示网络连接的实时更新列表。这对于监控网络使用情况并确定哪些主机正在消耗大量带宽非常有用。
2. **iotop**：`iotop` 是一个类似于 `top` 命令的工具，但是它**专注于显示磁盘 I/O 活动**。它可以实时显示系统上每个进程的磁盘 I/O 使用情况，包括读取和写入速率，以及累计的总量。
3. **netstat**：`netstat` 是一个用于显示网络连接、路由表和网络接口等网络相关信息的命令。它可以显示当前系统的网络连接状态，包括正在进行的连接、监听端口和路由表等。
4. **lsof**：`lsof` 是 "list open files" 的缩写，用于列出当前系统上已打开的文件。它可以显示**哪些进程正在使用哪些文件、目录或网络套接字等资源。**
5. **pstree**：`pstree` 是一个用于显示进程树的命令。它以树状结构显示当前系统中运行的进程及其关系，以便于理解进程之间的父子关系和衍生关系。
6. `stat` 是一个命令行实用程序，用于在类Unix操作系统中显示文件或文件系统的详细信息。当您运行 `stat` 命令，后面跟着文件或目录的名称时，它会提供诸如以下信息：
   1. 文件类型
   2. 权限
   3. inode 号
   4. UID 和 GID（用户和组标识符）
   5. 大小
   6. 时间戳（最后访问时间、最后修改时间和最后状态更改时间）
   7. 文件系统类型

7. 





# 虚拟机和docker区别

- **虚拟机提供了完整的虚拟化环境，每个虚拟机都运行独立的操作系统实例，而 Docker 则共享主机操作系统内核，容器之间相互隔离。**
- Docker 容器更加轻量级和高效，启动速度更快，资源占用更少，而虚拟机则较为笨重。
- Docker 适用于轻量级的应用容器化和快速部署，而虚拟机适用于需要完全隔离和独立的应用场景。



## docker底层

Docker 的底层是基于 Linux 内核的核心特性，主要是利用了 Linux 的容器技术。具体来说，Docker 使用了 Linux 内核的以下特性来实现容器化：

1. **Linux 容器（LXC）：** Docker 最初是建立在 LXC 上的，LXC 是 Linux 提供的一种基于内核的容器化技术，允许在单个 Linux 实例上运行多个隔离的 Linux 系统容器。
2. **命名空间（Namespaces）：** Linux 内核提供了多种命名空间，包括PID（进程）、UTS（主机名）、IPC（进程间通信）、网络和挂载。Docker 使用这些命名空间来实现容器之间的隔离，使得每个容器都拥有自己独立的进程、网络和文件系统等资源。
3. **控制组（cgroups）：** 控制组是 Linux 内核提供的一种资源限制和优先级控制机制，它允许对系统资源（如 CPU、内存、网络带宽等）进行分组和限制。Docker 使用控制组来限制容器的资源使用，以确保它们不会互相干扰。
4. **联合文件系统（UnionFS）：** Docker 使用联合文件系统来实现容器镜像的分层和共享。联合文件系统允许将多个文件系统挂载为单个文件系统，使得容器镜像可以由多个层次组成，每个层次都可以添加、修改或删除文件，而不会影响到其他层次，从而实现镜像的轻量化和高效共享。



# K8S学习















































