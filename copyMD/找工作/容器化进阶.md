---
title: 容器化进阶
top: false
cover: false
toc: true
mathjax: true
hidden: true
date: 2023-08-22 15:27:31
password:
summary:
tags:
- 容器化
- docker
categories:
- find JOB

---

# docker

## Docker与虚拟机的区别是什么？

- 虚拟机通过添加Hypervisor层（虚拟化中间层），虚拟出网卡、内存、CPU等虚拟硬件，再在其上建立虚拟机，**每个虚拟机都有自己的系统内核**。

- 而Docker容器则是**通过隔离（namesapce）的方式，将文件系统、进程、设备、网络等资源进行隔**离，**再对权限、CPU资源等进行控制（cgrou**p），最终让容器之间互不影响，容器无法影响宿主机。

与虚拟机相比，**容器资源损耗要少**。同样的宿主机下，能够建立容器的数量要比虚拟机多

但是，**虚拟机的安全性要比容器稍好**，而docker容器与宿主机共享内核、文件系统等资源，更有可能对其他容器、宿主机产生影响。



## 容器网络模式

**host模式**

host 模式 ：使用 `--net=host` 指定

相当于VMware 中的桥接模式，**与宿主机在同一个网络中，但是没有独立IP地址**

**container模式**

container模式：使用`–net=contatiner:NAME_or_ID` 指定

这个模式指定新创建的容器和已经存在的一个容器共享一个`Network Namespace`，而不是和宿主机共享。**新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围等**。 可以在一定程度上节省网络资源，容器内部依然不会拥有所有端口。

![image-20240418222301267](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/dfb0923408e017e9ae9ec40fd4745789/bc1b043429bbf984ba49bb1088a8ef37.png)





**none 模式**

none模式:使用 `--net=none`指定

使用none 模式，docker 容器有自己的`network Namespace`，但是并不为Docker 容器进行任何网络配置。也就是说，这个Docker 容器没有网卡，ip， 路由等信息。

这种网络模式下，容器只有lo 回环网络，没有其他网卡。

这种类型没有办法联网，但是封闭的网络能很好的保证容器的安全性



**bridge 模式**（**使用`docker run -p` 时，docker实际是在iptables做了DNAT规则，实现端口转发功能**。）

相当于Vmware中的 nat 模式，容器使用独立`network Namespace`，并连接到docker0虚拟网卡。通过docker0网桥以及`iptables nat`表配置与宿主机通信，此模式会为每一个容器分配`Network Namespace`、设置IP等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。

![null](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/dfb0923408e017e9ae9ec40fd4745789/ab1c125cd25b7526adb1e7d7c242b333.png)





## docker挂载

挂载目录数据卷，修改立即可见

挂着文件，修改了互不影响，除非重新运行。









## Docker的文件系统是什么

> UnionFS（联合文件系统）

UnionFs(联合文件系统)：Union文件系统(UnionFs)**是一种分层、轻量级并且高性能的文件系统**，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，UnionFs联合文件系统是Docker镜像的基础，**镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像特性**：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。



## docker制作镜像相关？



#### **分层结构**

**所有的容器都是共享宿主机的内核kernel**

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/dfb0923408e017e9ae9ec40fd4745789/3967a37da2f6681c528a571d3c0f27c5.png)





#### 容器 Copy-on-Write 特性

**当容器启动时，一个新的可写层被加载到镜像的顶部。**
**这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。**

所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在**容器层**中。
**只有容器层是可写的，容器层下面的所有镜像层都是只读的**。

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/dfb0923408e017e9ae9ec40fd4745789/e9dde80e1f3f7aace0de4b342a967f22.png)



