---
title: 数据库原理
top: false
cover: false
toc: true
mathjax: true
date: 2024-03-12 15:27:31
password:
summary:
tags:
- 数据库
categories:
- find JOB

---



## 事务



事务指的是**满足 ACID 特性的一组操作**，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

### ACID

#### 1. 原子性（Atomicity）
事务被视为不可分割的最小单元，**事务的所有操作要么全部提交成功，要么全部失败回滚。**

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 2. 一致性（Consistency）
**数据库在事务执行前后都保持一致性状态**。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

**一个有意思的说法**：AID都是手段，C是目的。再结合上这个回答言简意赅的表达。一致性究竟是什么就很清晰了，一致性是指：数据库状态与真实业务状态相一致。为了达成一致性，需要在事务中保证原子性、隔离性和持久性

分布式理论CAP理想的一致性模型是：当一条更新出现时，所有的观察者都能“看到”这个更新。

#### 3. 隔离性（Isolation）
**一个事务所做的修改在最终提交以前，对其它事务是不可见的。**

#### 4. 持久性（Durability）
**一旦事务提交，则其所做的修改将会永远保存到数据库中。**即使系统发生崩溃，事务执行的结果也不能丢失。



#### MySQL事务一致性，原子性是如何实现的？

> 首先是通过锁和mvcc实现了执行过程中的一致性和原子性

#### 事务的持久性是如何实现的？

> 使用Redo log保证了事务的持久性。当事务提交时，必须先将事务的所有日志写入日志文件进行持久化



### 并发一致性问题（丢脏不换）

#### 丢失修改（同时修改被覆盖）
指一个事务的更新操作被另一个事务的更新操作替换。常见情况是一个事务先提交，然后另一个事务覆盖了它的修改。

#### 读脏数据（读一次读到了一个失败的write的脏数据）
在不同的事务下，当前事务可以读取到另一个事务未提交的数据，导致读取到的数据不准确。

#### 不可重复读（多次读，读到了一个成功的write的前后两次数据）
**在一个事务内多次读取同一数据集合**，但在事务结束前，另一个事务修改了数据，导致多次读取结果不一致。

#### 幻影读（针对的集合等类型（属性变化）的不可重复读）
类似于不可重复读，但是是针对数据集合范围的操作。一个事务读取某个范围的数据，另一个事务在该范围内插入新数据，导致第一次和第二次读取结果不同。

并发不一致性问题的主要原因是事务隔离性的破坏，解决方法包括通过并发控制和事务隔离级别来保证数据的一致性。





## 锁

 ###  粒度

MySQL 中提供了两种封锁粒度：**行级锁以及表级锁，页面锁**。

`表级锁`： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。

`行级锁`： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。

`页面锁`： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。



应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。**

### 封锁类型

#### 读写锁
- X 锁（Exclusive互斥锁）：又称写锁，一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。，**期间其他事务不能对该数据对象加锁（其他事务不可读写）。**
- S 锁（Shared共享锁）：又称读锁，一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁，**允许对数据对象进行读取操作，但不允许更新操作**，**期间其他事务可以对该数据对象加 S 锁，但不能加 X 锁。**

因此，**读写锁可以做到读读并行，但是无法做到写读、写写并行。**



#### 意向锁（需要强调一下，意向锁是一种`不与行级锁冲突表级锁`，这一点非常重要。意向锁分为两种：）

我们先来看一下百度百科上对意向锁存在意义的描述：

> **如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。**
>
> 比如某个表里面已经有行共享锁了，当前想要给该表加入独占锁（这俩锁互斥），那么不需要一行行的扫描，只需要判断意向锁就行。
>
> 需要知道意向锁之间的兼容互斥性：即**意向锁之间是互相兼容的**。**意向锁不会与行级的共享 / 排他锁互斥！！！**
>
> |                      | 意向共享锁（IS） | 意向排他锁（IX） |
> | -------------------- | ---------------- | ---------------- |
> | **意向共享锁（IS）** | 兼容             | 兼容             |
> | **意向排他锁（IX）** | 兼容             | 兼容             |

意向锁（Intention Locks）支持多粒度封锁，引入了 IX/IS 锁。
- IS 锁：表示事务想要在表中的**某个数据行上**加 S 锁。
- IX 锁：表示事务想要在表中的某个数据行上加 X 锁。

意向锁的引入简化了对表级封锁的管理，使得事务能够更高效地加锁。



#### 乐观锁与悲观锁

 - **悲观锁**：认为数据在并发环境下会发生冲突，因此在读取数据时会先加锁，确保其他事务无法修改数据，直到当前事务完成操作。 
 -  **乐观锁**：认为数据在大多数情况下不会发生冲突，所以在操作数据时不加锁，而是在更新数据时检查是否有其他事务对数据进行了修改，若无修改则更新成功，否则进行相应的处理。 



## 事务隔离级别(两提两可)

**未提交读 (READ UNCOMMITTED)**
修改在事务中即使未提交，也对其他事务可见。

**已提交读 (READ COMMITTED)**
事务只能读取已提交的修改，未提交的修改对其他事务不可见。

**可重复读 (REPEATABLE READ)**
同一事务中多次读取数据结果一致。

**可串行化 (SERIALIZABLE)**
强制事务串行执行，防止并发一致性问题，需加锁实现。

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/45294bb9d60cfc2b07ffb63f8c3b4538.png)





## 多版本并发控制 (MVCC)

多版本并发控制（MVCC，Multiversion concurrency control）**可以看作是乐观控制的模式。**

**基本思想**

背景：**在实际场景中读操作往往多于写操作**，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，**写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。**

**在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。**

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读

MVCC （Multi-Version Concurrency Control, MVCC）利用多版本的思想，通过快照来实现并发控制，避免了不必要的加锁操作。事务的修改操作会为数据行创建新的版本快照，而读操作则可以读取旧版本快照。

**版本号**

**系统版本号 SYS_ID 是递增的**，每个事务开始时都有一个事务版本号 TRX_ID，记录在 Undo 日志中。

**Undo 日志（Undo log）**

**Undo 日志存储了数据行的多个版本快照**，通过回滚指针将它们连接起来。INSERT、UPDATE、DELETE 操作都会创建日志，并记录事务版本号。

**ReadView**

**用来判断当前版本数据的可见性。**

MVCC 维护了一个 ReadView 结构，包含了当前系统未提交的事务列表和最小、最大事务版本号。在进行 SELECT 操作时，**根据快照的事务版本号和 ReadView 进行判断，决定是否可以使用该快照**。

**快照读与当前读**

**SELECT 操作是快照读，不需要加锁**；读取某个时间节点的数据

**而INSERT、UPDATE、DELETE 操作需要加锁，以读取最新数据。**读取最新的

### 当前读和快照读分别是什么？

> **当前读 ：在锁定读（使用锁隔离事物）的时候读到的是最新版本的数据**
>
> **快照读：可重复读（repeatable-read）下 mvcc生效读取的是数据的快照，并不是最新版本的数据（未提交事物的数据**





# 关系数据库



### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

**如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。(Primary Key)**

**对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。**

**对于 A->B，B->C，则 A->C 是一个传递函数依赖**

### 范式

范式理论旨在解决数据库中的异常情况，其中高级别的范式依赖于低级别的范式。第一范式是最低级别的范式。

##### 第一范式 (1NF)
属性不可再分。

##### 第二范式 (2NF)
每个非主属性**完全依赖于键码（消除部分依赖）**。（就是非主属性完全依赖于主关键字。）（必须有个建码能够完全区分每一行）

可以通过分解表来解决

##### 第三范式 (3NF)** **[ 消除传递依赖 ]****
非主属性不传递依赖于键码。

**需要注意的是，可以通过分解关系来满足第二范式和第三范式的要求。**







# 其他问题



## 索引工作原理

> 索引的实现通常使用B树及其变种B+树



##  索引递增原理
一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

> 1. 如果表的类型为
>
>    ```
>    MyISAM
>    ```
>
>    ，ID为18 
>
>    - 因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失
>
> 2. 如果表的类型是
>
>    ```
>    InnoDB
>    ```
>
>    ，ID是15 
>
>    - InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失



## 一张表最多创建多少索引？

> 任何标准表最多可以创建16个索引列。





## 字段类型



MySQL 字段类型可以简单分为三大类：

- **数值类型**：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- **字符串类型**：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
- **日期时间类型**：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。





## MySQL 基础架构

**先连接，再查询（先查询，查不到就进行1语法分析，然后2mysql优化器优化执行方案，最后3执行器执行，从存储引擎获取数据）**

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/d76d8487602f99397c83879c99b5cabc.png)

， MySQL 主要由下面几部分构成：

- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存：** 执行查询语句的时候，会先查询缓存（**MySQL 8.0 版本后移除，因为这个功能不太实用**）。
- **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器：** 按照 MySQL 认为最优的方案去执行。
- **执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- **插件式存储引擎**：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎
  - MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库。**








## Mysql引擎

MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。

![查看 MySQL 提供的所有存储引擎](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/03acd5676d184db54f3ea3dedb217546.png)





## MyISAM 和 InnoDB 有什么区别？

MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。（InnoDB从社区转正了）

-----

InnoDB 支持**行级别的锁粒度**，MyISAM 不支持，只支持表级别的锁粒度。

MyISAM 不提供事务支持。InnoDB **提供事务支持**，实现了 SQL 标准定义了四个隔离级别。

MyISAM 不支持**外键**，而 InnoDB 支持。

MyISAM 不支持 **MVCC**，而 InnoDB 支持。

虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

MyISAM 不支持**数据库异常崩溃后的安全恢复**，而 InnoDB 支持。

InnoDB 的**性能**比 MyISAM 更强大。

-----

考虑需求高低，灵活选择存储引擎





## 能否单独为一张表设置存储引擎？

可以。我们可以为 不同的表设置不同的存储引擎







## MySQL 的隔离级别是基于锁实现的吗？
**MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。**


## MySQL 的默认隔离级别是什么?
MySQL **InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）**

## 能用 MySQL 直接存储文件（比如图片）吗？
可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。
建议用第三方对象存储服务OBS

## MySQL 如何存储 IP 地址？
可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。



## msyql缓存查询原理

 SQL 是**查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据**，看看之前有没有执行过这一条命令，这个**查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。**

**只要一个表有更新操作，那么这个表的查询缓存就会被清空。**

MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。



## 优化器

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

要想知道优化器选择了哪个索引，我们可以在查询语句最前面**加个 `explain`** 命令，这样就会输出这条 SQL 语句的执行计划





# 读写分离和分库分表详解



## 读写分离

**读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。** 这样的话，就能够小幅提升写性能，大幅提升读性能。

![读写分离示意图](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/699cf6d943a71dabf299988d715cd34b.png)



**主节点是写，从节点是读，要保证数据一致性。** 

**主从复制原理：**



![MySQL主从复制](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/aa0132ae2b9d0d0ad91f916847ff026a/37ccd07a71ef90bbfbb027b28c90d60a.png)MySQL主从复制

1. **主库将数据库中数据的变化写入到 binlog**
2. 从库连接主库
3. **从库会创建一个 I/O 线程向主库请求更新的 binlog**
4. 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收
5. **从库的 I/O 线程将接收的 binlog 写入到 relay log 中。**
6. **从库的 SQL 线程读取 relay log 同步数据本地**（**也就是再执行一遍 SQL** ）



由于主从更新会有延迟，最终会出现主从延迟问题。



## 分库分表

**分库** 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。（业务拆分和表的页拆分）

**垂直分库** 就是把单一数据库**按照业务进行划分，不同的业务使用不同的数据库**，进而将一个数据库的压力分担到多个数据库。

**水平分库** 是**把同一个表按一定规则拆分到不同的数据库中**，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。





**分表** 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。（**列拆分和行拆分**）

**垂直分表** 是对数据表列的拆分，把一张列比较多的表拆分为多张表。

举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。

**水平分表** 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。





### 如何对数据水平切分

常见的分片算法有：

- **哈希分片**：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。
- **范围分片**：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 `id` 为 `1~299999` 的记录分到第一个表， `300000~599999` 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。
- **映射表分片**：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。
- **一致性哈希分片**：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。
- **地理位置分片**：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。
- **融合算法分片**：灵活组合多种分片算法，比如将哈希分片和范围分片组合。



### 分库分表会带来什么问题呢？



**join 操作**：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。

**跨库聚合查询问题**：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。

**事务问题**：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。**需要引入分布式事务**

**分布式 ID**：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键













## Mysql死锁问题



### MySQL死锁的原因和处理方法

出现死锁的例子

```text
事务 a

表 t  id=100 更新  加行锁
表 t  id=200 更新  已加锁


事务 b

表 t  id=200 更新 加行锁
表 t  id=100 更新 已加锁
```

- 死锁与锁等待是两个概念 
  - 如未开启事务，多个客户端执行的insert操作
- 当多个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生了死锁

**办法**

- 充分利用索引，优化索引，尽量把有风险的事务sql使用上覆盖索
- kill id 杀死进程
- 拆分sql，严禁大事务





## mysql 的各种log



### bin log作用是什么？

> MySQL的**bin log日志是用来记录MySQL中增删改时的记录日志。**
>
> 当你的一条sql操作对数据库中的内容进行了更新，就会增加一条bin log日志。查询操作不会记录到bin log中。
>
> **bin log最大的用处就是进行**主从复制，以及数据库的恢复**

### redo log作用是什么？

> redo log是一种基于磁盘的数据结构，用来在MySQL宕机情况下将不完整的事务执行数据纠正，**redo日志记录事务执行后的状态**
>
> > **redo log就是为了恢复更新了内存但是由于宕机等原因没有刷入磁盘中的那部分数据**
>
> 实现了事务中的**持久性**，主要**用于掉电等故障恢复**；



### undo log作用是什么？

> **undo log主要用来回滚到某一个版本，是一种逻辑日志。**
>
> **undo log记录的是修改之前的数据，比如：当delete一条记录时，**undolog中会记录一条对应的insert记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过undo log中的记录内容并以此进行回滚。
>
> 现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。

