---
title: 计算机操作系统
top: false
cover: false
toc: true
mathjax: true
date: 2023-08-22 15:27:31
password:
summary:
tags:
- 计算机操作系统
categories:
- find JOB

---



# 概述



## 并发和并行

- **并发**：**指的是在同一时间段内，宏观上，多个任务都在执行，但不一定是同时刻。**操作系统会通过在任务之间快速切换来实现并发，每个任务都会被分配一些处理器时间，然后被迅速地切换，以使得用户感觉它们在同时执行。这种方式通常用于提高系统的吞吐量和资源利用率，尤其是在多任务环境下。
- **并行**：**指的是在同一时间段内，微观上，多个任务真正同时执行，每个任务都在不同的处理器核心上运行。**这种情况下，系统中会有多个处理器核心或者多个计算资源同时执行不同的任务，从而实现真正的并行计算。并行通常可以显著提高计算性能，特别是对于需要大量计算的任务。



### 共享

共享是指系统中的资源可以被**多个并发进程共同使用**。

有两种共享方式：**互斥共享和同时共享**。

**互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问**，需要用同步机制来实现互斥访问



### 虚拟

虚拟技术把**一个物理实体转换为多个逻辑实体**。

主要有两种虚拟技术：**时（时间）分复用技术和空（空间）分复用技术**。

多个进程能在同一个处理器上并发执行使用了时分复用技术，**让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换**。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，**当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。**（空分复用技术利用存储器的空闲空间分区域存放和运行其他的多道程序，以此来提高内存的利用率。）



### 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进



## 操作系统基本功能

### 1. 进程管理
- 进程控制
- 进程同步
- 进程通信
- 死锁处理
- 处理机调度

### 2. 内存管理
- 内存分配
- 地址映射
- 内存保护与共享
- 虚拟内存

### 3. 文件管理
- 文件存储空间的管理
- 目录管理
- 文件读写管理和保护

### 4. 设备管理
- 缓冲管理
- 设备分配
- 设备处理
- 虚拟设备





## 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行**系统调用从而陷入内核，由操作系统代为完成。**



## 宏内核与微内核

### 1. 宏内核
**宏内核将操作系统功能作为一个紧密结合的整体放到内核中。**各模块共享信息，因此具有**很高的性能**。

### 2. 微内核
微内核是为了降低内核的复杂性而将一部分操作系统功能移出内核的结构。**这些功能根据分层原则划分成若干服务，相互独立。**

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。由于需要频繁地在用户态和核心态之间进行切换，**会有一定的性能损失。**



## 中断分类

### 1. 外中断
**由 CPU 执行指令以外的事件引起**，如：

- **I/O 完成中断**：表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。
- 时钟中断
- 控制台中断
等。

### 2. 异常
**由 CPU 执行指令的内部事件引起**，如：

- 非法操作码
- **地址越界**
- 算术溢出
等。

### 3. 陷入

**在用户程序中使用系统调用**。



# 进程管理

## 进程与线程

### 进程

**进程是资源分配的基本单位。**

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

### 线程

**线程是独立调度的基本单位。**

**一个进程中可以有多个线程，它们共享进程资源。**

### 区别

Ⅰ 拥有资源

**进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源**。

Ⅱ 调度

**线程是独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

**由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销**。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

**线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。（Inter-Process Communication，进程间通信）是一种机制，**





## 进程状态的切换

![img](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/2e685a6e7775ffcdc0a6d33a93becab8/5b84e44a43e7a933f2c853e374589635.png)



- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- **只有就绪态和运行态可以相互转换，其它的都是单向转换**。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- **阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。**





## 进程调度与切换

进程调度算法根据不同环境有不同的目标和方法。

### 批处理系统
这种系统不涉及用户交互，主要目标是保证吞吐量和周转时间。

- **先来先服务（FCFS）**
按照请求的顺序调度，适合长作业，但可能会导致短作业等待时间过长。

- **短作业优先（SJF）**
按估计运行时间最短的顺序调度，但可能导致长作业饿死。

- **最短剩余时间优先（SRTN）**
抢占式版本的SJF，按剩余运行时间的顺序调度，可能会导致长作业被中断。

### 交互式系统
这种系统需要快速响应用户交互。

- **时间片轮转**
按FCFS原则排队，每次分配一个时间片给队首进程，但时间片大小影响效率。

- **优先级调度**
为每个进程分配优先级，按照优先级调度，可动态调整优先级以避免低优先级进程长时间等待。

- **多级反馈队列**
设置多个队列，每个队列时间片大小不同(先小时间片队列，再大时间片队列)，进程在队列间移动，可减少进程切换次数。

### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时



## 进程同步

### **临界区**
**对临界资源进行访问的那段代码称为临界区,(即资源占用的那部分)**。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```c
// entry section
// critical section;
// exit section
```

### **同步与互斥**
**同步**：多个进程因为合作产生的直接制约关系，使得进程有一定的**先后执行关系。**
**互斥**：多个进程在**同一时刻只有一个进程能进入临界区**。

### **信号量**
**信号量（Semaphore）是一个整型变量**，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

```c
down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
```

**down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。**

如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

### 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。



**管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。**

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。



**PV操作是用于操作信号量的原语，用于底层的资源管理和同步。而管程中的wait和signal操作是高级别的同步机制，封装了对共享数据的访问和条件变量的等待/唤醒操作，更适用于实现复杂的同步和通信。**





## 进程通信（IPC）

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而**进程同步是一种目的**。也可以说，**为了能够达到进程同步的目的，需要让进程进行通信**，传输一些进程同步所需要的信息。





**进程通信（IPC）** 是多个进程之间传输信息的手段，而进程同步是控制多个进程按一定顺序执行的目的。

### **1. 管道**
- 半双工通信
- 只能在父子进程或兄弟进程中使用

### **2. FIFO（命名管道）**
- 去除了管道的父子进程限制
- 常用于客户-服务器应用程序

### **3. 消息队列**
- 独立于读写进程存在
- 避免了同步阻塞问题
- 可以选择性地接收消息

### **4. 信号量**
- 用于为多个进程提供对共享数据对象的访问控制

### **5. 共享存储**
- 多个进程共享一个存储区
- 速度快，但需要信号量来同步访问

### **6. 套接字**
- 可用于不同机器间的进程通信





# 死锁

## 必要条件

- **互斥**：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- **不可抢占**：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- **环路等待**：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。



## 处理办法

### **1. 鸵鸟策略**：
   - 忽略死锁，即不采取任何措施来解决或避免死锁，而是等待死锁自行解除。

### **2. 死锁检测与死锁恢复**：
   - **周期性地检测系统中是否存在死锁**，一旦检测到死锁，系统会采取措施来恢复正常运行，通常是终止一个或多个死锁进程，释放资源。

### **3. 死锁预防**：

 **在程序运行之前预防发生死锁。**

   - **破坏互斥条件**：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

   - **破坏占有和等待条件**：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

   - **破坏不可抢占条件**

   - **破坏环路等待**：给资源统一编号，进程只能按编号顺序来请求资源。

### **4. 死锁避免**：
   - 在资源分配过程中采取预防措施，通过动态地分配资源来避免系统进入死锁状态，通常需要使用一些算法和策略来实现。



# 内存管理



## 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

**(说白了就是把硬盘利用换页虚拟成内存，使得内存在不太损失性能的情况下，得到逻辑上的扩展，用时间换空间)**

**程序使用内存逻辑**：为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。







## 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

**一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量**。（相当于第多少页，多少行）



## 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

**页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。**



这段文本总结了几种常见的页面置换算法，其目标是减少页面置换频率，从而降低缺页率。以下是对每种算法的简要概述：

1. **最佳 (OPT)**：
   - 选择被换出的页面是在未来最长时间内不会被访问的页面。
   - 算法理论上最优，但无法实现，因为无法预测未来页面访问模式。

2. **最近最久未使用 (LRU)**：
   - 根据最近页面访问情况，选择最久未被使用的页面进行置换。
   - 实现上需要维护一个访问链表，代价较高。

3. **最近未使用 (NRU)**：
   - 每个页面有两个状态位：R（最近被访问）和M（最近被修改）。
   - 根据页面的R和M位将页面分成不同类别，并随机选择一个非空类别中的页面进行置换。

4. **先进先出 (FIFO)**：
   - 选择最早被加入内存的页面进行置换。
   - 可能会置换出经常被访问的页面，导致较高的缺页率。

5. **第二次机会算法**：
   - 在FIFO算法的基础上，通过设置R位来给予某些页面第二次机会。
   - 当页面需要被替换时，如果该页面的R位为1，则将其移到链表尾端，并将R位清零。

6. **时钟算法**：
   - 使用一个环形链表来存储页面，并使用一个指针指向最老的页面。
   - 当页面需要被替换时，时钟指针向前移动，并检查指向的页面的R位。



## 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

1. **单元大小**：
   - 分页：内存被划分为固定大小的页，通常大小为 4KB 或 4MB。
   - 分段：内存被划分为不同大小的段，每个段可以有不同的大小，适应不同大小的逻辑单位。
2. **逻辑结构映射**：
   - 分页：逻辑地址被划分成固定大小的页，页内的逻辑结构可能被打破。
   - 分段：逻辑地址空间被划分成不同大小的段，每个段可以包含一个逻辑单位，比如代码段、数据段等，更好地反映程序的逻辑结构。
3. **碎片问题**：
   - 分页：可能存在内部碎片，即一页中可能会有未被完全利用的空间。
   - 分段：可能存在外部碎片，即分段之间的空闲空间无法被利用。



## 段页式（目前的大部分系统是这样）

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。