---
title: java-JVM学习
top: false
cover: false
toc: true
mathjax: true
hidden: true
date: 2024-03-25 15:27:31
password:
summary:
tags:
- java
categories:
- find JOB

---

## 什么是JVM？

> JVM（Java Virtual Machine）是用于运行Java字节码的虚拟机，**包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器**。JVM运行在操作系统之上，不与硬件设备直接交互。
>
> **Java源文件在通过编译器之后被编译成相应的.Class文件**（字节码文件），**.Class文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行**。每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。在一个Java进程开始运行后，虚拟机就开始实例化了，有多个进程启动就会实例化多个虚拟机实例。进程退出或者关闭，则虚拟机实例消亡，在多个虚拟机实例之间不能共享数据

## JVM虚拟机包含了哪些区域？

> Java虚拟机包括一个**类加载器子系统**（Class Loader SubSystem）、**运行时数据区**（Runtime Data Area）、**执行引擎和本地接口库**（Native Interface Library）。本地接口库通过调用本地方法库（Native Method Library）与操作系统交互
>
> ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b80edfddf34ff1955a9cadb4410002~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
>
> 其中：
>
> - 类加载器子系统用于将编译好的**.Class文件加载到JVM**中；
> - 运行时数据区用于**存储在JVM运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；**
> - **执行引擎包括即时编译器和垃圾回收器**，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；
> - **本地接口库用于调用操作系统的本地方法**库完成具体的指令操作。





### java内存分区

![image-20221026100332889](https://www.javaxiaobear.cn/assets/image-20221026100332889-itJQs2Iu.png)

### java堆

**Java堆(Java Heap)是线程共享的**，一般来说也是JVM管理最大的一块内存区域，**同时也是垃圾收集器GC的主要管理区域。**

Java堆在JVM启动时创建，作用是：**存放对象实例**



###  java本地方法栈

本地方法栈(Native Method Stack)也是线程私有的，与虚拟机栈的作用非常类似。 区别是虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行Native方法服务的。







## 在JVM后台运行的线程有哪些？

> - 虚拟机线程（JVMThread）：虚拟机线程在JVM到达安全点（SafePoint）时出现。
> - 周期性任务线程：通过定时器调度线程来实现周期性操作的执行。
> - **GC（Garbage Collection）线程**：GC线程支持JVM中不同的垃圾回收活动。
> - 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JVM跨平台的具体实现。
> - 信号分发线程：接收发送到JVM的信号并调用JVM方法







## 如何确定垃圾可以回收？

> 方法：引用计数器和可达性分析
>
> **引用计数器**：在Java 中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加l ；在为对象删除一个引用时， 引进计数减l ；如果一个对象的引用计数为0 ，则表示此刻该对象没有被引用，可以被回收。
>
> 存在的问题：如果两个互相引用，则不会回收
>
> **可达性分析**：为了解决引用计数器方法的循环引用问题，首先定义一些GC Root s 对象，然后以这些GC Roots 对象作为起
>  点向下搜索，如果在GC roots 和一个对象之间没有可达路径， 则称该对象是不可达的。不可达对象要经过至少两次标记才能判定其是否可以被囚lj史，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。







## 垃圾回收算法

标记清除（ Mark-Sweep ）

标记复制（ Copying ）

标记整理( Mark-Compact ）

分代收集（ Generational Collecting ）







### 分代收集算法？

> 分代收集算法根据对象的不同类型将内存划分为不同的区域， JVM 将堆划分为新生代和老年代。**新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少**。因此， JVM 根据不同的区域对象的特点选择了不同的算法



### 标记清除算法？

> 标记清除，顾名思义，就是把标记的清除掉，分两个阶段，第一阶段，标记，第二阶段，清除；
>
> **首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，**也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程，它是最早出现也是最基础的算法

**效率低下，内存碎片化**

### 标记复制

为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，**将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时**，将**这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。**

**导致内存利用率不足**

### 标记-整理算法

复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。

**标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。**

![标记-整理算法](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dcb1edc483949ea8c18e040fd94bb6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

