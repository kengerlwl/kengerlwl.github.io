---
title: java-JVM学习
top: false
cover: false
toc: true
mathjax: true
hidden: true
date: 2024-03-25 15:27:31
password:
summary:
tags:
- java
categories:
- find JOB

---

## 什么是JVM？

> JVM（Java Virtual Machine）是用于运行Java字节码的虚拟机，**包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器**。JVM运行在操作系统之上，不与硬件设备直接交互。
>
> **Java源文件在通过编译器之后被编译成相应的.Class文件**（字节码文件），**.Class文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行**。每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。在一个Java进程开始运行后，虚拟机就开始实例化了，有多个进程启动就会实例化多个虚拟机实例。进程退出或者关闭，则虚拟机实例消亡，在多个虚拟机实例之间不能共享数据

## JVM虚拟机包含了哪些区域？

> Java虚拟机包括一个**类加载器子系统**（Class Loader SubSystem）、**运行时数据区**（Runtime Data Area）、**执行引擎和本地接口库**（Native Interface Library）。本地接口库通过调用本地方法库（Native Method Library）与操作系统交互
>
> ![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/f2e69943a7177210b2e5fff570bf4e7b/73d29dcb23f68f1f4695f67fd4e00fd3.png)
>
> 其中：
>
> - 类加载器子系统用于将编译好的**.Class文件加载到JVM**中；
> - 运行时数据区用于**存储在JVM运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；**
> - **执行引擎包括即时编译器和垃圾回收器**，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；
> - **本地接口库用于调用操作系统的本地方法**库完成具体的指令操作。





### java内存分区

![image-20221026100332889](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/f2e69943a7177210b2e5fff570bf4e7b/8d49402e9a8099495c09a33c227b839e.png)

### java堆

**Java堆(Java Heap)是线程共享的**，一般来说也是JVM管理最大的一块内存区域，**同时也是垃圾收集器GC的主要管理区域。**

Java堆在JVM启动时创建，作用是：**存放对象实例**



###  java本地方法栈

本地方法栈(Native Method Stack)也是线程私有的，与虚拟机栈的作用非常类似。 区别是虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行Native方法服务的。







## 在JVM后台运行的线程有哪些？

> - 虚拟机线程（JVMThread）：虚拟机线程在JVM到达安全点（SafePoint）时出现。
> - 周期性任务线程：通过定时器调度线程来实现周期性操作的执行。
> - **GC（Garbage Collection）线程**：GC线程支持JVM中不同的垃圾回收活动。
> - 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JVM跨平台的具体实现。
> - 信号分发线程：接收发送到JVM的信号并调用JVM方法







## 如何确定垃圾可以回收？

> 方法：引用计数器和可达性分析
>
> **引用计数器**：在Java 中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加l ；在为对象删除一个引用时， 引进计数减l ；如果一个对象的引用计数为0 ，则表示此刻该对象没有被引用，可以被回收。
>
> 存在的问题：如果两个互相引用，则不会回收
>
> **可达性分析**：为了解决引用计数器方法的循环引用问题，首先定义一些GC Root s 对象，然后以这些GC Roots 对象作为起
>  点向下搜索，如果在GC roots 和一个对象之间没有可达路径， 则称该对象是不可达的。不可达对象要经过至少两次标记才能判定其是否可以被囚lj史，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。







## 垃圾回收算法

标记清除（ Mark-Sweep ）

标记复制（ Copying ）

标记整理( Mark-Compact ）

分代收集（ Generational Collecting ）







### 分代收集算法？

> 分代收集算法根据对象的不同类型将内存划分为不同的区域， JVM 将堆划分为新生代和老年代。**新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少**。因此， JVM 根据不同的区域对象的特点选择了不同的算法。**老年代的垃圾回收算法根据老年代的特性有两类，标记清除和标记整理。**



### 标记清除算法？

> 标记清除，顾名思义，就是把标记的清除掉，分两个阶段，第一阶段，标记，第二阶段，清除；
>
> **首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，**也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程，它是最早出现也是最基础的算法

**效率低下，内存碎片化**

### 标记复制

为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，**将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时**，将**这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。**

**导致内存利用率不足**

### 标记-整理算法

复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。

**标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。**

![标记-整理算法](https://raw.githubusercontent.com/kengerlwl/kengerlwl.github.io/master/image/f2e69943a7177210b2e5fff570bf4e7b/9f54c5467aad11f9dd339ba0f2e05b8e.png)







## JMM主内存和工作内存





![JMM(Java 内存模型)](https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png)

**什么是主内存？什么是本地内存？**

- **主内存**：**所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中**。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
- **本地内存**：**每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本**。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。**如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在**，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：

1. 线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。
2. 线程 2 到主存中读取对应的共享变量的值。

### 
