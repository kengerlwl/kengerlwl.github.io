---
title: Spring Cloud.md
top: false
cover: false
toc: true
mathjax: true
hidden: true
date: 2024-04-06 15:27:31
password:
summary:
tags:
- spring
- java
categories:
- find JOB

---



## 为什么需要微服务

### 传统的Web项目

传统的WEB应用核心分为业务逻辑、适配器以及API或通过UI访问的WEB界面。业务逻辑定义业务流程、业务规则以及领域实体。适配器包括数据库访问组件、消息组件以及访问接口等。

尽管也是遵循模块化开发，但最终它们会打包并部署为单体式应用。例如Java应用程序会被打包成WAR，部署在Tomcat或者Jetty上。

这种单体应用比较适合于小项目，优点是：

- 开发简单直接，集中式管理
- 基本不会重复开发
- 功能都在本地，没有分布式的管理开销和调用开销

它的缺点也十分明显，特别对于互联网公司来说：

- **开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断**
- 代码维护难：代码功能耦合在一起，新人不知道何从下手
- 部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长
- **稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉**
- **扩展性不够：无法满足高并发情况下的业务需求**

### 微服务项目

**微服务架构的优点**

- 解决了复杂性问题

它将单体应用分解为一组服务。虽然功能总量不变，但应用程序已被分解为可管理的模块或服务。这些服务定义了明确的RPC或消息驱动的API边界。微服务架构强化了应用模块化的水平，而这通过单体代码库很难实现。因此，微服务开发的速度要快很多，更容易理解和维护。

- 单独开发每个服务，与其他服务互不干扰

只要符合服务API契约，开发人员可以自由选择开发技术。这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。

- 可以独立部署每个微服务

开发人员无需协调对服务升级或更改的部署。这些更改可以在测试通过后立即部署。所以微服务架构也使得CI／CD成为可能。

## 实现微服务要解决的四个问题？

> 1. 客户端如何访问这些服务？
>    1. 微服务网关API Gateway
>       - 提供统一服务入口，让微服务对前台透明
>       - 聚合后台的服务，节省流量，提升性能
>       - 提供安全，过滤，流控等API管理功能
> 2. 服务之间如何通信？
>    1. Open Feign， Nacos
>    1. Ribbon实现不同微服务的通信的负载均衡
> 3. 这么多服务，怎么找?
>    1. Nacos
> 4. 服务挂了怎么办？
>    1. 重试机制
>    2. 限流
>    3. 熔断机制
>    4. 负载均衡
>    5. 降级（本地缓存）

## Spring Cloud有哪些组件?

> - 服务发现--Netflix Eureka， 或Nacos
> - 客户端负载均衡--Netflix Ribbon
> - 断路器（服务熔断）--Netflix Hystrix
> - 服务网关--Netflix Zuul， Spring Cloud Gateway
> - 分布式配置--Spring Cloud Config
>   - SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。
>   - 基于Nacos也可以实现分布式配置中心。



## Hystrix断路器



### **具体机制**：

> Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。



- 跳闸机制：当某服务的错误率超过一定的阈值时，Hystrix可以自动或手动跳闸，停止请求该服务一段时间。
- 资源隔离：Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等待，从而加速失败判定。
- 监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求



### 雪崩效应，你了解吗？

> 在微服务架构中，一个请求需要调用多个服务是非常常见的。如客户端访问A服务，而A服务需要调用B服务，**B服务需要调用C服务，由于网络原因或者自身的原因，如果B服务或者C服务不能及时响应，A服务将处于阻塞状态，直到B服务C服务响应**。此时若有大量的请求涌入，容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。

**由于有雪崩效应，所以需要服务熔断**

### 服务降级，你了解吗？

> 所谓降级，就是当某个服务熔断之后，**服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值**。也可以理解为兜底方法。

### 服务限流，你了解吗？

> 限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳固运行，一旦达到的需要限制的阈值，就需要限制流量并采取少量措施以完成限制流量的目的。







## CAP理论

分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。其中**C是最终要实现的一个关键特性，因此，是只有CA或者CP。**

### 一致性

一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。

### 可用性

可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。

### 分区容忍性

网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。

在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。

## BASE

**BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。**

BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的**核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。**







## 分布式会出现的问题

- 全局id问题，分布式id
- 分布式事务问题。如果单体应用被拆分成了微服务，那么三个服务不能跨事务，需要用到分布式事务，
  - Spring Cloud Seata？
- 分布式锁
  - redis setnx+ expire + 版本号



